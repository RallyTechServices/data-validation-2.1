<!DOCTYPE html>
<html>
<head>
    <title>Data Exception Drilldown App</title>
    <!--  (c) 2016 CA Technologies.  All Rights Reserved. -->
    <!--  Build Date: Fri Jan 20 2017 17:05:41 GMT-0700 (MST) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Fri Jan 20 2017 17:05:41 GMT-0700 (MST)";
        var BUILDER = "kcorkan";
        var CHECKSUM = 104379508841;
    </script>
    
    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350,
    
    informationalConfig: null,
    
    items: [{xtype:'container', itemId:'information' }],
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/var BUILDER = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
       
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
   
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    var stored_checksum = me._generateChecksum(text);
                    if ( CHECKSUM !== stored_checksum ) {
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    _addToContainer: function(container){
        var config = Ext.apply({
            xtype:'container',
            height: 200,
            overflowY: true
        }, this.informationalConfig);
        
        container.add(config);
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if ( !Ext.isEmpty( this.informationalConfig ) ) {
            var container = this.down('#information');
            this._addToContainer(container);
            
        }
        
        if (! app.isExternal() ) {
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            dock: 'bottom',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                },
                failure: function(msg){
                    console.log("oops:",msg);
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml,
                doc: 'top'
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            dock:'bottom',
            html:"This app was created by the CA AC Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html: Ext.String.format("Build date/time: {0} ({1})",
                    APP_BUILD_DATE,
                    BUILDER)
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('CA.technicalservices.dataquality.common.BaseRule',{
    extend: 'Ext.Base',
    alias:  'widget.tsrule_base',
    /*
     * [{Rally.wsapi.data.Model}] portfolioItemTypes the list of PIs available
     * we're going to use the first level ones (different workspaces name their portfolio item levels differently)
     */
    portfolioItemTypes:[],
    /**
     *
     * @cfg
     * {String} model The name of a record type that this rule applies to
     */
    model: null,
    /**
     *
     * @cfg {String} a human-readable label for the chart that will be made from the rule
     */
    label: 'No label supplied for this rule',

    description: 'This is a description for the base rule',

    query: null,

    baseQuery: null,

    fetchFields: null,

    detailFetchFields: null,

    constructor: function(config) {
        this.initialConfig = config;
        Ext.apply(this,config);
    },
    getUseRallyGrid: function(){
        return false;
    },
    getFeatureName: function(){
        return this.portfolioItemTypes && this.portfolioItemTypes.length > 1 &&
            this.portfolioItemTypes[0].TypePath.replace('PortfolioItem/','');
    },
    getDescription: function() {
        return this.description;
    },
    getFetchFields: function() {
        return this.fetchFields || ['FormattedID'];
    },
    getDetailFetchFields: function(){
        return this.detailFetchFields || this.getFetchFields();
    },
    getLabel: function() {
        return this.label;
    },
    getModel: function() {
        return this.model;
    },
    getConfig: function(){
        return this.initialConfig;
    },
    getCountConfig: function(){
        return {
            model: this.getModel(),
            fetch: this.getFetchFields(),
            filters: this.getFilters()
        };
    },
    getTotalCountConfig: function(){
        return {
            model: this.getModel(),
            fetch: ['ObjectID'],
            filters: this.getBaseFilters()
        };
    },
    getBaseFilters: function(){

        if (this.baseQuery){
            return Rally.data.wsapi.Filter.fromQueryString(this.baseQuery);
        }

        return Ext.create('Rally.data.wsapi.Filter', {
            property:'ObjectID',
            operator:'>',
            value: 0
        });
    },
    getFilters: function() {
        if (this.query){
            return Rally.data.wsapi.Filter.fromQueryString(this.query);
        }
        return Ext.create('Rally.data.wsapi.Filter', {
            property:'ObjectID',
            operator:'>',
            value: 0
        });
    },
    getDetailFilters: function(){
        return this.getFilters();
    },
    getDetailColumnCfgs: function(){
        return this.getDetailFetchFields();
    },
    _loadWsapiRecords: function(config) {
        var deferred = Ext.create('Deft.Deferred');

        Ext.create('Rally.data.wsapi.Store',config).load({
            callback: function(records, operation){
                if (operation.wasSuccessful()){
                    var result = {};
                    result[config.model] = records;
                    deferred.resolve(records);
                } else {
                    deferred.reject(operation.error.errors.join(','));
                }
            }
        });
        return deferred.promise;
    }
});
Ext.define('CA.technicalservices.dataquality.common.LeafProjectBuildPercentRule',{
    extend: 'CA.technicalservices.dataquality.common.BaseRule',
    alias:  'widget.rule_leafprojectbuildpercentrule',

    getUseRallyGrid: function(){
        return true;
    },
    getCount: function(projectID, projectUtility){
        var deferred = Ext.create('Deft.Deferred');

        if (this.recordData){
            var count = this._processRecords(projectID, projectUtility).length;
            deferred.resolve(count);
        } else {
            var projectRef= '/project/' + projectID,
                config = {
                    model: this.getModel(),
                    fetch: this.getFetchFields(),
                    filters: this.getFilters(),
                    context: {project: projectRef, projectScopeDown: true},
                    limit: Infinity
                };

            this._loadWsapiRecords(config).then({
                success: function(records){
                    this.recordData = _.map(records, function(r){ return r.getData(); });
                    var count = this._processRecords(projectID, projectUtility).length;
                    deferred.resolve(count);
                },
                scope: this
            });
        }
        return deferred;
    },
    _processRecords: function(projectID,projectUtility){
        var children = projectUtility.getAllChildren(projectID),
            oids = [];

        Ext.Array.each(this.recordData, function(r){
            if (Ext.Array.contains(children, r.ObjectID)){
                oids.push(r.ObjectID);
            }
        });

       return oids;
    },
    getDetailFilters: function(projectID, projectUtility){
        var oids = this._processRecords(projectID, projectUtility);
        var filters = Ext.Array.map(oids, function(o){ return {
                property: 'ObjectID',
                value: o
            };
        });
        if (filters && filters.length > 1){
            return Rally.data.wsapi.Filter.or(filters);
        }
        return filters;

    },
    getDetailColumnConfigs: function(){
        return [{
            dataIndex: 'Name',
            text: 'Name'
        },{
            dataIndex: 'c_BuildPercent',
            text: 'Build Percent'
        }]
    }
});
Ext.define('CA.technicalservices.dataquality.common.TeamAssignmentInconsistency',{
    extend: 'CA.technicalservices.dataquality.common.BaseRule',
    alias:  'widget.rule_teamassignmentinconsistency',
    getCount: function(projectID, projectUtility){
        var deferred = Ext.create('Deft.Deferred');

        var projectRef= '/project/' + projectID,
            config = {
                model: this.getModel(),
                fetch: ['ObjectID','Project','Owner','c_WorkdayTeam'],
                filters: this.getFilters(),
                context: {project: projectRef, projectScopeDown: true},
                compact: false,
                pageSize: 2000,
                limit: Infinity
            };

        this._loadWsapiRecords(config).then({
            success: function(records){
                var recordData = _.map(records, function(r){ return r.getData(); }),
                    obj = this._processRecords(recordData);

                if (!this.flaggedItems){
                    this.flaggedItems = {};
                }
                this.flaggedItems[projectID] = obj;

                deferred.resolve(obj.count);
            },
            scope: this
        });
        return deferred;
    },
    _processRecords: function(recordData){
        var flaggedStories = [],
            count = 0;

        for (var i=0; i<recordData.length; i++){
            var r = recordData[i];
            if (Number(r.Owner.c_WorkdayTeam) !== r.Project.ObjectID){
                flaggedStories.push(r.ObjectID);
                count++;
            }
        }
        return {
            count: count,
            flaggedStories: flaggedStories
        };
        //return affectedProjects;
    },
    getDetailFilters: function(projectID, projectUtility){

        var obj = this.flaggedItems[projectID],
            stories = obj.flaggedStories;

        var filters = Ext.Array.map(stories, function(o){ return {
                property: 'ObjectID',
                value: o
            };
        });

        if (filters && filters.length > 1){
             return Rally.data.wsapi.Filter.or(filters);
        }
        if (filters.length === 0){
            filters = {
                property: 'ObjectID',
                value: 0
            };
        }
        return filters;
    }
});
/**
 * Created by kcorkan on 11/4/16.
 */
Ext.define('recordHolder',{
    data: {},
    constructor: function(config) {
        Ext.apply(this, config);
    },

    get: function(field) {
        return this.data[field];
    }
});

Ext.define('Rally.technicalservices.FileUtilities', {
    singleton: true,
    logger: new Rally.technicalservices.Logger(),

    saveCSVToFile:function(csv,file_name,type_object){
        if (type_object === undefined){
            type_object = {type:'text/csv;charset=utf-8'};
        }
        this.saveAs(csv,file_name, type_object);
    },

    saveAs: function(textToWrite, fileName)
    {
        this.logger.log('saveAs:', fileName);

        if (Ext.isIE9m){
            Rally.ui.notify.Notifier.showWarning({message: "Export is not supported for IE9 and below."});
            return;
        }

        var textFileAsBlob = null;
        try {
            textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});
        }
        catch(e){
            this.logger.log('Caught an error ', e);

            window.BlobBuilder = window.BlobBuilder ||
                window.WebKitBlobBuilder ||
                window.MozBlobBuilder ||
                window.MSBlobBuilder;
            if (window.BlobBuilder ) { //&&  e.name === 'TypeError'){
                bb = new BlobBuilder();
                bb.append([textToWrite]);
                textFileAsBlob = bb.getBlob("text/plain");
            }

        }

        if (!textFileAsBlob){
            Rally.ui.notify.Notifier.showWarning({message: "Export is not supported for this browser."});
            return;
        }

        var fileNameToSaveAs = fileName;

        if (Ext.isIE10p){
            window.navigator.msSaveOrOpenBlob(textFileAsBlob,fileNameToSaveAs); // Now the user will have the option of clicking the Save button and the Open button.
            return;
        }

        var url = this.createObjectURL(textFileAsBlob);

        if (url){
            var downloadLink = document.createElement("a");
            if ("download" in downloadLink){
                downloadLink.download = fileNameToSaveAs;
            } else {
                //Open the file in a new tab
                downloadLink.target = "_blank";
            }

            downloadLink.innerHTML = "Download File";
            downloadLink.href = url;
            if (!Ext.isChrome){
                // Firefox requires the link to be added to the DOM
                // before it can be clicked.
                downloadLink.onclick = this.destroyClickedElement;
                downloadLink.style.display = "none";
                document.body.appendChild(downloadLink);
            }
            downloadLink.click();
        } else {
            Rally.ui.notify.Notifier.showError({message: "Export is not supported "});
        }

    },
    createObjectURL: function ( file ) {
        if ( window.webkitURL ) {
            return window.webkitURL.createObjectURL( file );
        } else if ( window.URL && window.URL.createObjectURL ) {
            return window.URL.createObjectURL( file );
        } else {
            return null;
        }
    },
    saveTextAsFile: function(textToWrite, fileName) {
        var textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});
        var fileNameToSaveAs = fileName;

        var downloadLink = document.createElement("a");
        downloadLink.download = fileNameToSaveAs;
        downloadLink.innerHTML = "Download File";
        if (window.webkitURL != null)
        {
            // Chrome allows the link to be clicked
            // without actually adding it to the DOM.
            downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
        }
        else
        {
            // Firefox requires the link to be added to the DOM
            // before it can be clicked.
            downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
            downloadLink.onclick = destroyClickedElement;
            downloadLink.style.display = "none";
            document.body.appendChild(downloadLink);
        }
        downloadLink.click();
    },
    destroyClickedElement: function(event)
    {
        document.body.removeChild(event.target);
    },
    convertDataArrayToCSVText: function(data_array, requestedFieldHash){

        var text = '';
        Ext.each(Object.keys(requestedFieldHash), function(key){
            text += requestedFieldHash[key] + ',';
        });
        text = text.replace(/,$/,'\n');

        Ext.each(data_array, function(d){
            Ext.each(Object.keys(requestedFieldHash), function(key){
                if (d[key]){
                    if (typeof d[key] === 'object'){
                        if (d[key].FormattedID) {
                            text += Ext.String.format("\"{0}\",",d[key].FormattedID );
                        } else if (d[key].Name) {
                            text += Ext.String.format("\"{0}\",",d[key].Name );
                        } else if (!isNaN(Date.parse(d[key]))){
                            text += Ext.String.format("\"{0}\",",Rally.util.DateTime.formatWithDefaultDateTime(d[key]));
                        }else {
                            text += Ext.String.format("\"{0}\",",d[key].toString());
                        }
                    } else {
                        text += Ext.String.format("\"{0}\",",d[key] );
                    }
                } else {
                    text += ',';
                }
            },this);
            text = text.replace(/,$/,'\n');
        },this);
        return text;
    },
    _getCSVFromWsapiBackedGrid: function(grid,skip_headers) {
        var deferred = Ext.create('Deft.Deferred');
        var store = Ext.create('Rally.data.wsapi.Store',{
            fetch: grid.getStore().config.fetch,
            filters: grid.getStore().config.filters,
            model: grid.getStore().config.model,
            pageSize: 200
        });

        var columns = grid.columns;

        var record_count = grid.getStore().getTotalCount(),
            page_size = grid.getStore().pageSize,
            pages = Math.ceil(record_count/page_size),
            promises = [];

        for (var page = 1; page <= pages; page ++ ) {
            promises.push(this.loadStorePage(grid, store, columns, page, pages));
        }
        Deft.Promise.all(promises).then({
            success: function(csvs){
                var csv = [];
                if ( !skip_headers ) {
                    csv.push('"' + this._getHeadersFromGrid(grid).join('","') + '"');
                }
                _.each(csvs, function(c){
                    _.each(c, function(line){
                        csv.push(line);
                    });
                });
                csv = csv.join('\r\n');
                deferred.resolve(csv);
                Rally.getApp().setLoading(false);
            }
        });
        return deferred.promise;
    },

    getCSVFromRows: function(scope, grid, rows) {
        var me = this;
        var columns = grid.columns;
        var store = grid.getStore();

        console.log('getCSVFromRows');

        var model = grid.model;

        var csv = [];

        csv.push('"' + this._getHeadersFromGrid(grid).join('","') + '"');

        Ext.Array.each(rows,function(row){

            csv.push( me._getCSVFromRecord(Ext.create('recordHolder', { data:row}), grid, store) );
        });

        csv = csv.join('\r\n');
        return csv;
    },

    // custom grid assumes there store is fully loaded
    _getCSVFromCustomBackedGrid: function(grid, skip_headers) {
        var deferred = Ext.create('Deft.Deferred');
        var store = Ext.clone( grid.getStore() );
        var columns = grid.columns;
        Rally.getApp().setLoading("Generating CSV...");

        var record_count = store.getTotalCount(),
            page_size = store.pageSize,
            pages = Math.ceil(record_count/page_size),
            promises = [];

        for (var page = 1; page <= pages; page ++ ) {
            promises.push(this.loadStorePage(grid, store, columns, page, pages));
        }

        Deft.Promise.all(promises).then({
            scope: this,
            success: function(csvs){
                var csv = [];
                if ( !skip_headers ) {
                    csv.push('"' + this._getHeadersFromGrid(grid).join('","') + '"');
                }
                _.each(csvs, function(c){
                    _.each(c, function(line){
                        csv.push(line);
                    });
                });
                csv = csv.join('\r\n');
                deferred.resolve(csv);
                Rally.getApp().setLoading(false);
            }
        });
        return deferred.promise;
    },

    _getHeadersFromGrid: function(grid) {
        var headers = [];
        var columns = grid.columns;

        Ext.Array.each(columns,function(column){
            if ( column.hidden ) { return; }

            if ( column.dataIndex || column.renderer ) {
                if ( column.csvText ) {
                    headers.push(column.csvText.replace('&nbsp;',' '));
                } else if ( column.text )  {
                    headers.push(column.text.replace('&nbsp;',' '));
                }
            }
        });

        return headers;
    },

    _getColumnNamesFromGrid: function(grid) {
        var names = [];
        var columns = grid.columns;

        Ext.Array.each(columns,function(column){
            if ( column.dataIndex || column.renderer ) {
                names.push(column.dataIndex);
            }
        });

        return names;
    },
    /*
     * will render using your grid renderer.  If you want it to ignore the grid renderer,
     * have the column set _csvIgnoreRender: true
     */
    getCSVFromGrid:function(app, grid, skip_headers){
        this.logger.log("Exporting grid with store type:", Ext.getClassName(grid.getStore()));

        if ( Ext.getClassName(grid.getStore()) != "Rally.data.custom.Store" ) {
            return this._getCSVFromWsapiBackedGrid(grid,skip_headers);
        }

        return this._getCSVFromCustomBackedGrid(grid,skip_headers);
    },
    loadStorePage: function(grid, store, columns, page, total_pages){
        var deferred = Ext.create('Deft.Deferred');
        this.logger.log('loadStorePage',page, total_pages);

        store.loadPage(page, {
            callback: function (records) {
                var csv = [];
                Rally.getApp().setLoading(Ext.String.format('Page {0} of {1} loaded',page, total_pages));
                for (var i = 0; i < records.length; i++) {
                    var record = records[i];
                    csv.push( this._getCSVFromRecord(record, grid, store) );
                }
                deferred.resolve(csv);
            },
            scope: this
        });
        return deferred;
    },

    _getCSVFromRecord: function(record, grid, store) {
        //console.log('record:', record);

        var mock_meta_data = {
            align: "right",
            classes: [],
            cellIndex: 9,
            column: null,
            columnIndex: 9,
            innerCls: undefined,
            recordIndex: 5,
            rowIndex: 5,
            style: "",
            tdAttr: "",
            tdCls: "x-grid-cell x-grid-td x-grid-cell-headerId-gridcolumn-1029 x-grid-cell-last x-unselectable",
            unselectableAttr: "unselectable='on'"
        };

        var node_values = [];
        var columns = grid.columns;

        Ext.Array.each(columns, function (column) {
            if (column.xtype == 'rallyrowactioncolumn'  || column.xtype == 'tsrowactioncolumn') {
                return;
            }

            if ( column.hidden ) {
                return;
            }

            if (column.dataIndex) {
                var column_name = column.dataIndex;

                var display_value = record.get(column_name);

                if (!column._csvIgnoreRender && ( column.renderer || column.exportRenderer) ) {
                    if (column.exportRenderer) {
                        display_value = column.exportRenderer(display_value, mock_meta_data, record, 0, 0, store, grid.getView());
                    } else {
                        display_value = column.renderer(display_value, mock_meta_data, record, 0, 0, store, grid.getView());
                    }
                }
                node_values.push(display_value);
            } else {
                var display_value = null;
                if (!column._csvIgnoreRender && column.renderer) {
                    if (column.exportRenderer) {
                        display_value = column.exportRenderer(display_value, mock_meta_data, record, record, 0, 0, store, grid.getView());
                    } else {
                        display_value = column.renderer(display_value, mock_meta_data, record, record, 0, 0, store, grid.getView());
                    }
                    node_values.push(display_value);
                }
            }
        }, this);

        var csv_string = "";
        Ext.Array.each(node_values, function(node_value,idx){
            if ( idx > 0 ) {
                csv_string = csv_string + ",";
            }
            if (/^=/.test(node_value) ) {
                csv_string = csv_string + node_value;
            } else {
                csv_string = csv_string + '"' + node_value + '"';
            }

        });

        return csv_string;
    }

});
Ext.define('CA.technicalservices.dataquality.common.Rules',{
    singleton: true,

    prettyDashboardColumns: 4,
    prettyThreshholdGreen: 10,
    prettyThreshholdYellow: 20,

    rulesConfig: [{

        label: 'Orphaned Features',
        description: 'Counting only features identified as Build',
        model: 'PortfolioItem/Feature',
        unitLabel: 'features',
        query: '((Parent = null) AND (InvestmentCategory = "Build"))',
        detailFetchFields: ['FormattedID','Name','Parent','State'],
        flagRed: true,
        flagYellow: false
    },{

        label: 'Orphaned Stories',
        flagRed: false,
        flagYellow: false,
        description: 'Counting stories where:<br><li>Assigned Team a build percent != 0 (is > 0 or null). ' +
        '<li>Story is not in "Unelaborated" ScheduleState ' +
        '<li>Story Type is "Standard" or null' +
        '<li>Story has no Feature',
        unitLabel: 'stories',
        model: 'HierarchicalRequirement',
        detailFetchFields: ['FormattedID','Name','Feature','Parent','ScheduleState','c_StoryType'],
        query: '(((c_StoryType = "Standard") OR (c_StoryType = "")) AND (((Feature = null) AND (ScheduleState > "Unelaborated")) AND (Project.c_BuildPercent != 0)))'
    },{

        label: 'Stories not sized',
        flagRed: false,
        flagYellow: true,
        description: 'Counting stories where:<br><li>Assigned Team a build percent != 0 (is > 0 or null). ' +
        '<li>Parent Initiative has an Investment Category = "Build" ' +
        '<li>Parent Initiative state is "In-Progress" or "Staging" ' +
        '<li>Story schedule state is in "Defined", "In-Progress" or "Complete" ' +
        '<li>Story Plan Estimate is null ',
        unitLabel: 'stories',
        model: 'HierarchicalRequirement',
        detailFetchFields: ['FormattedID','Name','Feature','PlanEstimate','ScheduleState'],
        query: '((((((Feature.Parent.State.Name = "In-Progress") OR (Feature.Parent.State.Name = "Staging") AND (((ScheduleState = "Defined") OR (ScheduleState = "In-Progress")) OR (ScheduleState = "Completed"))) AND (Feature.Parent.InvestmentCategory = "Build")) AND (Project.c_BuildPercent != 0)) AND (PlanEstimate = ""))'

    },{

        label: 'Active Stories / Inactive Initiatives',
        watchColor: null,
        description: 'Counting stories where:<br><li>Assigned Team a build percent != 0 (is > 0 or null). ' +
        '<li>Parent Initiative has an Investment Category = "Build" ' +
        '<li>Parent Initiative is NOT active (state is NOT "In-Progress" or "Staging") ' +
        '<li>Story is active (schedule state is "Defined", "In-Progress" or "Complete") ' ,
        unitLabel: 'stories',
        model: 'HierarchicalRequirement',
        detailFetchFields: ['FormattedID','Name','Feature','ScheduleState'],
        query: '((((Feature.Parent.State.Name != "In-Progress") AND (Feature.Parent.State.Name != "Staging")) AND (((ScheduleState = "Defined") OR (ScheduleState = "In-Progress")) OR (ScheduleState = "Completed")) AND ((c_StoryType = "Standard") OR (c_StoryType = ""))) AND ((Feature.Parent.InvestmentCategory = "Build") AND (Project.c_BuildPercent != 0)))'

    },{

            label: 'Active Stories on Parent Teams',
        watchColor: null,
        description: 'Counting stories where:<br><li>Assigned Team a build percent != 0 (is > 0 or null). ' +
        '<li>Parent Initiative has an Investment Category = "Build" ' +
        '<li>Parent Initiative is active (state is "In-Progress" or "Staging") ' +
        '<li>Story state is active (state is "Defined", "In-Progress" or "Complete") ' ,
        unitLabel: 'stories',
        detailFetchFields: ['FormattedID','Name','Feature','ScheduleState','Project'],
        model: 'HierarchicalRequirement',
        query: '((((Feature.Parent.State.Name = "In-Progress") OR (Feature.Parent.State.Name = "Staging")) AND (((ScheduleState = "Defined") OR (ScheduleState = "In-Progress")) OR (ScheduleState = "Completed"))) AND (((Feature.Parent.InvestmentCategory = "Build") AND (Project.Children.State = "Open")) AND (Project.c_BuildPercent != 0)))'

    },{

        label: 'Strategy Category',
        watchColor: null,
        description: 'Counting initiatives where:<br>' +
        '<li>Initiative has an Investment Category = "Build" ' +
        '<li>Strategy Category is null',
        unitLabel: 'initiatives',
        detailFetchFields: ['FormattedID','Name','State','InvestmentCategory'],
        model: 'PortfolioItem/Initiative',
        query: '((InvestmentCategory = "Build") AND (c_StrategyCategory = ""))'

    },{

        label: 'Active Stories / Team with no people',
        watchColor: null,
        description: 'Counting stories where:<br>' +
        '<li>Initiative has an Investment Category = "Build" ' +
        '<li>Initiative is active (state is "In-Progress" or "Staging") ' +
        '<li>Story state is active (state is "Defined", "In-Progress" or "Complete") ' +
        '<li>Story is on a Team with no Team Members</li>',
        unitLabel: 'stories',
        model: 'HierarchicalRequirement',
        detailFetchFields: ['FormattedID','Name','Feature','ScheduleState','Project'],
        query: '((((Feature.Parent.State.Name = "In-Progress") OR (Feature.Parent.State.Name = "Staging")) AND (((ScheduleState = "Defined") OR (ScheduleState = "In-Progress")) OR (ScheduleState = "Completed"))) AND ((Feature.Parent.InvestmentCategory = "Build") AND (Project.TeamMembers.ObjectID = "null")))'

    },{

        label: 'Features not sized',
        watchColor: null,
        description: 'Counting features where:' +
        '<li>Initiative is Build' +
        '<li>Initiative is active (state is "In-Progress" or "Staging")' +
        '<li>Preliminary Estimate is null',
        model: 'PortfolioItem/Feature',
        unitLabel: 'features',
        detailFetchFields: ['FormattedID','Name','Parent','PreliminaryEstimate','State','Project'],
        query: '((((Parent.State.Name = "In-Progress") OR (Parent.State.Name = "Staging")) AND (Parent.InvestmentCategory = "Build")) AND (PreliminaryEstimate = ""))'
    }],


    //Add rules to this array that you only want on the "Pretty" dashboard and not in the drilldown app
    prettyRules: [{
        label: 'Misaliged Feature / Intiative Investment Category',
        description: 'Counting features where:' +
        '<li>Initiative Investment Category is "Build"' +
        '<li>Initiative is active (state is "In-Progress" or "Staging")' +
        '<li>Feature Investment Category is NOT "Build"',
        model: 'PortfolioItem/Feature',
        unitLabel: 'features',
        detailFetchFields: ['FormattedID','Name','Parent','InvestmentCategory','State','Project'],
        query: '(((((Parent.State.Name = "Elaborate") OR (Parent.State.Name = "In-Progress")) OR (Parent.State.Name = "Staging")) AND (Parent.InvestmentCategory = "Build")) AND (InvestmentCategory != "Build"))'

    }],

    //Add rules to this array that you only want in the "Drilldown App" but not on the "Pretty" dashboard.
    drilldownRules: [{
        label: 'Build Percent null',
        description: 'Counting leaf node projects where the Build Percent field is null',
        model: 'Project',
        detailFetchFields: ['Name','c_BuildPercent'],
        query: '((c_BuildPercent = "") AND (Children.State != "Open"))',
        exceptionClass: 'rule_leafprojectbuildpercentrule'
    },{
        label: 'Teams assignment is inconsistent between Owner and Story',
        description: 'Counting Active stories and child stories where the project object id is different than the value in the Workday Team on the owners person record.  Data will not include stories with Owners that do not belong to a Workday Team',
        model: 'HierarchicalRequirement',
        detailFetchFields: ['ObjectID','Name','Owner','Project'],
        query: '((((ScheduleState = "Defined") OR (ScheduleState = "In-Progress")) OR (ScheduleState = "Completed")) AND (Owner.c_WorkdayTeam != ""))',
        exceptionClass: 'rule_teamassignmentinconsistency'
    }]

});
/**
 * Created by kcorkan on 11/4/16.
 */
Ext.define('recordHolder',{
    data: {},
    constructor: function(config) {
        Ext.apply(this, config);
    },

    get: function(field) {
        return this.data[field];
    }
});

Ext.define('Rally.technicalservices.FileUtilities', {
    singleton: true,
    logger: new Rally.technicalservices.Logger(),

    saveCSVToFile:function(csv,file_name,type_object){
        if (type_object === undefined){
            type_object = {type:'text/csv;charset=utf-8'};
        }
        this.saveAs(csv,file_name, type_object);
    },

    saveAs: function(textToWrite, fileName)
    {
        this.logger.log('saveAs:', fileName);

        if (Ext.isIE9m){
            Rally.ui.notify.Notifier.showWarning({message: "Export is not supported for IE9 and below."});
            return;
        }

        var textFileAsBlob = null;
        try {
            textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});
        }
        catch(e){
            this.logger.log('Caught an error ', e);

            window.BlobBuilder = window.BlobBuilder ||
                window.WebKitBlobBuilder ||
                window.MozBlobBuilder ||
                window.MSBlobBuilder;
            if (window.BlobBuilder ) { //&&  e.name === 'TypeError'){
                bb = new BlobBuilder();
                bb.append([textToWrite]);
                textFileAsBlob = bb.getBlob("text/plain");
            }

        }

        if (!textFileAsBlob){
            Rally.ui.notify.Notifier.showWarning({message: "Export is not supported for this browser."});
            return;
        }

        var fileNameToSaveAs = fileName;

        if (Ext.isIE10p){
            window.navigator.msSaveOrOpenBlob(textFileAsBlob,fileNameToSaveAs); // Now the user will have the option of clicking the Save button and the Open button.
            return;
        }

        var url = this.createObjectURL(textFileAsBlob);

        if (url){
            var downloadLink = document.createElement("a");
            if ("download" in downloadLink){
                downloadLink.download = fileNameToSaveAs;
            } else {
                //Open the file in a new tab
                downloadLink.target = "_blank";
            }

            downloadLink.innerHTML = "Download File";
            downloadLink.href = url;
            if (!Ext.isChrome){
                // Firefox requires the link to be added to the DOM
                // before it can be clicked.
                downloadLink.onclick = this.destroyClickedElement;
                downloadLink.style.display = "none";
                document.body.appendChild(downloadLink);
            }
            downloadLink.click();
        } else {
            Rally.ui.notify.Notifier.showError({message: "Export is not supported "});
        }

    },
    createObjectURL: function ( file ) {
        if ( window.webkitURL ) {
            return window.webkitURL.createObjectURL( file );
        } else if ( window.URL && window.URL.createObjectURL ) {
            return window.URL.createObjectURL( file );
        } else {
            return null;
        }
    },
    saveTextAsFile: function(textToWrite, fileName) {
        var textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});
        var fileNameToSaveAs = fileName;

        var downloadLink = document.createElement("a");
        downloadLink.download = fileNameToSaveAs;
        downloadLink.innerHTML = "Download File";
        if (window.webkitURL != null)
        {
            // Chrome allows the link to be clicked
            // without actually adding it to the DOM.
            downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
        }
        else
        {
            // Firefox requires the link to be added to the DOM
            // before it can be clicked.
            downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
            downloadLink.onclick = destroyClickedElement;
            downloadLink.style.display = "none";
            document.body.appendChild(downloadLink);
        }
        downloadLink.click();
    },
    destroyClickedElement: function(event)
    {
        document.body.removeChild(event.target);
    },
    convertDataArrayToCSVText: function(data_array, requestedFieldHash){

        var text = '';
        Ext.each(Object.keys(requestedFieldHash), function(key){
            text += requestedFieldHash[key] + ',';
        });
        text = text.replace(/,$/,'\n');

        Ext.each(data_array, function(d){
            Ext.each(Object.keys(requestedFieldHash), function(key){
                if (d[key]){
                    if (typeof d[key] === 'object'){
                        if (d[key].FormattedID) {
                            text += Ext.String.format("\"{0}\",",d[key].FormattedID );
                        } else if (d[key].Name) {
                            text += Ext.String.format("\"{0}\",",d[key].Name );
                        } else if (!isNaN(Date.parse(d[key]))){
                            text += Ext.String.format("\"{0}\",",Rally.util.DateTime.formatWithDefaultDateTime(d[key]));
                        }else {
                            text += Ext.String.format("\"{0}\",",d[key].toString());
                        }
                    } else {
                        text += Ext.String.format("\"{0}\",",d[key] );
                    }
                } else {
                    text += ',';
                }
            },this);
            text = text.replace(/,$/,'\n');
        },this);
        return text;
    },
    _getCSVFromWsapiBackedGrid: function(grid,skip_headers) {
        var deferred = Ext.create('Deft.Deferred');
        var store = Ext.create('Rally.data.wsapi.Store',{
            fetch: grid.getStore().config.fetch,
            filters: grid.getStore().config.filters,
            model: grid.getStore().config.model,
            pageSize: 200
        });

        var columns = grid.columns;

        var record_count = grid.getStore().getTotalCount(),
            page_size = grid.getStore().pageSize,
            pages = Math.ceil(record_count/page_size),
            promises = [];

        for (var page = 1; page <= pages; page ++ ) {
            promises.push(this.loadStorePage(grid, store, columns, page, pages));
        }
        Deft.Promise.all(promises).then({
            success: function(csvs){
                var csv = [];
                if ( !skip_headers ) {
                    csv.push('"' + this._getHeadersFromGrid(grid).join('","') + '"');
                }
                _.each(csvs, function(c){
                    _.each(c, function(line){
                        csv.push(line);
                    });
                });
                csv = csv.join('\r\n');
                deferred.resolve(csv);
                Rally.getApp().setLoading(false);
            }
        });
        return deferred.promise;
    },

    getCSVFromRows: function(scope, grid, rows) {
        var me = this;
        var columns = grid.columns;
        var store = grid.getStore();

        console.log('getCSVFromRows');

        var model = grid.model;

        var csv = [];

        csv.push('"' + this._getHeadersFromGrid(grid).join('","') + '"');

        Ext.Array.each(rows,function(row){

            csv.push( me._getCSVFromRecord(Ext.create('recordHolder', { data:row}), grid, store) );
        });

        csv = csv.join('\r\n');
        return csv;
    },

    // custom grid assumes there store is fully loaded
    _getCSVFromCustomBackedGrid: function(grid, skip_headers) {
        var deferred = Ext.create('Deft.Deferred');
        var store = Ext.clone( grid.getStore() );
        var columns = grid.columns;
        Rally.getApp().setLoading("Generating CSV...");

        var record_count = store.getTotalCount(),
            page_size = store.pageSize,
            pages = Math.ceil(record_count/page_size),
            promises = [];

        for (var page = 1; page <= pages; page ++ ) {
            promises.push(this.loadStorePage(grid, store, columns, page, pages));
        }

        Deft.Promise.all(promises).then({
            scope: this,
            success: function(csvs){
                var csv = [];
                if ( !skip_headers ) {
                    csv.push('"' + this._getHeadersFromGrid(grid).join('","') + '"');
                }
                _.each(csvs, function(c){
                    _.each(c, function(line){
                        csv.push(line);
                    });
                });
                csv = csv.join('\r\n');
                deferred.resolve(csv);
                Rally.getApp().setLoading(false);
            }
        });
        return deferred.promise;
    },

    _getHeadersFromGrid: function(grid) {
        var headers = [];
        var columns = grid.columns;

        Ext.Array.each(columns,function(column){
            if ( column.hidden ) { return; }

            if ( column.dataIndex || column.renderer ) {
                if ( column.csvText ) {
                    headers.push(column.csvText.replace('&nbsp;',' '));
                } else if ( column.text )  {
                    headers.push(column.text.replace('&nbsp;',' '));
                }
            }
        });

        return headers;
    },

    _getColumnNamesFromGrid: function(grid) {
        var names = [];
        var columns = grid.columns;

        Ext.Array.each(columns,function(column){
            if ( column.dataIndex || column.renderer ) {
                names.push(column.dataIndex);
            }
        });

        return names;
    },
    /*
     * will render using your grid renderer.  If you want it to ignore the grid renderer,
     * have the column set _csvIgnoreRender: true
     */
    getCSVFromGrid:function(app, grid, skip_headers){
        this.logger.log("Exporting grid with store type:", Ext.getClassName(grid.getStore()));

        if ( Ext.getClassName(grid.getStore()) != "Rally.data.custom.Store" ) {
            return this._getCSVFromWsapiBackedGrid(grid,skip_headers);
        }

        return this._getCSVFromCustomBackedGrid(grid,skip_headers);
    },
    loadStorePage: function(grid, store, columns, page, total_pages){
        var deferred = Ext.create('Deft.Deferred');
        this.logger.log('loadStorePage',page, total_pages);

        store.loadPage(page, {
            callback: function (records) {
                var csv = [];
                Rally.getApp().setLoading(Ext.String.format('Page {0} of {1} loaded',page, total_pages));
                for (var i = 0; i < records.length; i++) {
                    var record = records[i];
                    csv.push( this._getCSVFromRecord(record, grid, store) );
                }
                deferred.resolve(csv);
            },
            scope: this
        });
        return deferred;
    },

    _getCSVFromRecord: function(record, grid, store) {
        //console.log('record:', record);

        var mock_meta_data = {
            align: "right",
            classes: [],
            cellIndex: 9,
            column: null,
            columnIndex: 9,
            innerCls: undefined,
            recordIndex: 5,
            rowIndex: 5,
            style: "",
            tdAttr: "",
            tdCls: "x-grid-cell x-grid-td x-grid-cell-headerId-gridcolumn-1029 x-grid-cell-last x-unselectable",
            unselectableAttr: "unselectable='on'"
        };

        var node_values = [];
        var columns = grid.columns;

        Ext.Array.each(columns, function (column) {
            if (column.xtype == 'rallyrowactioncolumn'  || column.xtype == 'tsrowactioncolumn') {
                return;
            }

            if ( column.hidden ) {
                return;
            }

            if (column.dataIndex) {
                var column_name = column.dataIndex;

                var display_value = record.get(column_name);

                if (!column._csvIgnoreRender && ( column.renderer || column.exportRenderer) ) {
                    if (column.exportRenderer) {
                        display_value = column.exportRenderer(display_value, mock_meta_data, record, 0, 0, store, grid.getView());
                    } else {
                        display_value = column.renderer(display_value, mock_meta_data, record, 0, 0, store, grid.getView());
                    }
                }
                node_values.push(display_value);
            } else {
                var display_value = null;
                if (!column._csvIgnoreRender && column.renderer) {
                    if (column.exportRenderer) {
                        display_value = column.exportRenderer(display_value, mock_meta_data, record, record, 0, 0, store, grid.getView());
                    } else {
                        display_value = column.renderer(display_value, mock_meta_data, record, record, 0, 0, store, grid.getView());
                    }
                    node_values.push(display_value);
                }
            }
        }, this);

        var csv_string = "";
        Ext.Array.each(node_values, function(node_value,idx){
            if ( idx > 0 ) {
                csv_string = csv_string + ",";
            }
            if (/^=/.test(node_value) ) {
                csv_string = csv_string + node_value;
            } else {
                csv_string = csv_string + '"' + node_value + '"';
            }

        });

        return csv_string;
    }

});
Ext.define('CA.techservices.validator.Validator',{
    alias: 'widget.tsvalidator',

    logger: new Rally.technicalservices.Logger(),
    /**
     *
     * [{rule}] An array of validation rules
     */
    rules: [],

    /**
     *
     */
    deliveryTeamProjects: [],       // listing of projects where a SCHEDULED feature might reside

    businessPlanningProjects: [],   // listing of programs where an UNSCHEDULED feature might reside

    recordsByModel: {},

    projectUtility: null, //This is the class passed in by initialize that holds the project hierarchy.  This is used for bucketing data
    currentProject: null, //Current project ObjectID so that we can determine which projects to display as "categories"

    categoryField: 'Project',

    // fields that all rules should fetch
    fetchFields: [],
    /**
     *
     * a hash containing events for a data point e.g.,
     *
     * points will include a field called _records holding the associated records
     * and each record will have a field called __ruleText holding a statement about
     * its violation
     *
     *     {
     *          click: function() {
     *          me.showDrillDown(this._records,this._name);
     *      }
     */
    pointEvents: null,
    /**
     *
     * a hash of filters by model type.  Filter will be ANDed to the filters we get from the validation rules
     * (which are themselves ORed together).
     */
    baseFilters: {},

    constructor: function(config) {
        Ext.apply(this,config);

        var rules = [];

        Ext.Array.each(this.rules, function(rule){

            var name = rule.exceptionClass || 'tsrule_base';
            if ( !Ext.isEmpty(name) ) {
                delete rule.xtype;
                rules.push(Ext.createByAlias('widget.' + name, rule));
            }
        });

        this.rules = rules;
    },
    getRules: function(){
        return this.rules;
    },
    getRule: function(ruleName){
        var rule = null,
            label = ruleName && ruleName.ruleConfig && ruleName.ruleConfig.label;

        Ext.Array.each(this.getRules(), function(r){
            if (r.label === label){
                rule = r;
                return false;
            }
        });
        return rule;
    },
    /**
     * getGridData
     *
     * @returns [{},{},...] (an array of data objects that can be used in a custom store
     *
     * the "category" field is the same as the category for the violation
     * each rule will be a column and the resulting grid will show a count
     *
     */
    getGridData: function(){
        var deferred = Ext.create('Deft.Deferred');
        var buckets = this.projectUtility.getProjectDirectChildren(this.currentProject),
            promises = [],
            me = this;
        Ext.Array.each(buckets, function(p){
            promises.push(me.fetchGridRow(p));
        });

        Deft.Promise.all(promises).then({
            success:function(rows){
                deferred.resolve(rows);
            },
            failure: function(msg){
                deferred.reject(msg);
            }
        });
        return deferred;
    },
    refreshRecord: function(record){
        var projectID = record.get('bucket');
        
        this.fetchGridRow(projectID).then({
            success: function(row){
                Ext.Object.each(row, function(field, value){
                    record.set(field, value);
                });
            }
        });
    },
    fetchGridRow: function(projectID){
        var deferred = Ext.create('Deft.Deferred'),
            me = this,
            promises = [],
            projectUtility = this.projectUtility,
            projectName = this.projectUtility.getProjectName(projectID),
            projectRef= '/project/' + projectID,
            rules = this.getRules();

        Ext.Array.each(rules, function(rule){
            var config = {
                model: rule.getModel(),
                fetch: rule.getFetchFields(),
                filters: rule.getFilters(),
                context: {project: projectRef, projectScopeDown: true}
            };
            if (!rule.exceptionClass){
                promises.push(me._loadWsapiCount(config));
            } else {
                promises.push(rule.getCount(projectID, projectUtility));
            }
        }, this);

        Deft.Promise.all(promises).then({
            success: function(results){
                var row = {
                    bucket: projectName,
                    bucketID: projectID,
                };
                for (var i=0; i < rules.length; i++){
                    var name = rules[i].getLabel();
                    row[name] = {
                        ruleConfig: rules[i].getConfig(),
                        value: results[i] || 0
                    };
                }
                deferred.resolve(row);
            },
            failure: function(msg){
                deferred.reject(msg);
            }
        });
        return deferred;
    },

    _loadWsapiRecords: function(config) {
        var deferred = Ext.create('Deft.Deferred');

        Ext.create('Rally.data.wsapi.Store',config).load({
            callback: function(records, operation){
                if (operation.wasSuccessful()){
                    var result = {};
                    result[config.model] = records;
                    deferred.resolve(records);
                } else {
                    deferred.reject(operation.error.errors.join(','));
                }
            }
        });
        return deferred.promise;
    },
    _loadWsapiCount: function(config){
        var deferred = Ext.create('Deft.Deferred');

        config.pageSize = 1;
        config.limit = 1;

        Ext.create('Rally.data.wsapi.Store',config).load({
            callback: function(records, operation){
                if (operation.wasSuccessful()){
                    deferred.resolve(operation.resultSet.totalRecords);
                } else {
                    deferred.reject(operation.error.errors.join(','));
                }
            }
        });
        return deferred.promise;
    }
});
Ext.define('CA.technicalservices.utils.ProjectUtilities',{

    fetch: ['ObjectID','Name','Parent'],
    mixins: {
        observable: 'Ext.util.Observable'
    },
    constructor: function(config){
        this.mixins.observable.constructor.call(this, config);

        var fetch = Ext.Array.merge(this.fetch, config && config.fetch || []);

        Ext.create('Rally.data.wsapi.Store',{
            model: 'Project',
            fetch: ['ObjectID','Name','Parent'],
            limit: Infinity,
            context: {project: null},
            pageSize: 2000,
            compact: false
        }).load({
            callback: function(records, operation){
                if (operation.wasSuccessful()){
                    this._buildProjectParentHash(records);
                } else {
                    this.fireEvent('onerror', "Error fetching projects: " + operation.error && operation.error.errors.join(','));
                }
            },
            scope: this
        });
    },
    _buildProjectParentHash: function(records){

        var projectHash = {};
        Ext.Array.each(records, function(r){
            projectHash[r.get('ObjectID')] = r.getData();
        });
        this.projectHash= projectHash;
        this.fireEvent('ready');
    },
    getAncestry: function(projectID){
        var parent = this.projectHash[projectID].Parent && this.projectHash[projectID].Parent.ObjectID || null,
            ancestry = this.projectHash[projectID] && this.projectHash[projectID].ancestors;

        if (!ancestry){

            ancestry = [Number(projectID)];
            if (parent){
                do {
                    ancestry.unshift(parent);
                    parent = this.projectHash[parent] &&
                        this.projectHash[parent].Parent &&
                        this.projectHash[parent].Parent.ObjectID || null;

                } while (parent);
            }
            this.projectHash[projectID].ancestors = ancestry;
        }
        return ancestry;
    },
    getProjectAncestor: function(projectID, projectLevel){
        var ancestry = this.getAncestry(projectID);

        if (ancestry.length >= projectLevel){
            return ancestry[projectLevel - 1];
        }
        return null;
    },
    getProjectName: function(projectID){
        return this.projectHash[projectID] &&  this.projectHash[projectID].Name || "Unknown";
    },
    getProjectLevel: function(projectID){
        var ancestory = this.getAncestry(projectID);
        return ancestory.length;
    },
    isProjectLeafNode: function(projectID){
        var isLeafNode = true;
        var ms = Date.now();
        Ext.Object.each(this.projectHash, function(key, data){
            if (data.Parent && data.Parent.ObjectID === projectID){
                isLeafNode = false;
                return false;
            }
        });

        return isLeafNode;
    },
    getProjectDirectChildren: function(projectID){
        var children = [];
        Ext.Object.each(this.projectHash, function(key, data){
            if (data.Parent && data.Parent.ObjectID === projectID){
                children.push(key);
            }
        });

        if (children.length === 0){
            children.push(projectID);
        }
        return children;
    },
    getAllChildren: function(projectID){
        var children = []
            projectID = Number(projectID);

        Ext.Object.each(this.projectHash, function(key, data){
            var ancestry = this.getAncestry(key);

            if (Ext.Array.contains(ancestry, projectID)){
                children.push(Number(key));
            }
        }, this);

       return children;
    }

});
Ext.define("data-exception-summary", {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    defaults: { margin: 10 },

    integrationHeaders : {
        name : "data-exception-summary"
    },

    layout: 'hbox',
    items: [
        {xtype:'container', itemId:'grid_box', flex: 1},
        {xtype:'container', itemId:'detail_box'}
    ],

    config: {
        defaultSettings: {
            projectBuildPercentField: 'c_BuildPercent'
        }
    },

    launch: function() {
       this._initializeApp();
    },
    _initializeApp: function(){

        this.projectUtility = Ext.create('CA.technicalservices.utils.ProjectUtilities',{
            fetch: [this.getSetting('projectBuildPercentField')],
            listeners: {
                onerror: this.showErrorNotification,
                ready: this.initializeValidator,
                scope: this
            }
        });
    },

    showErrorNotification: function(msg){
        Rally.ui.notify.Notifier.showError({message:msg});
    },
    initializeValidator: function(){
        var me = this;

        this.validator = this._createValidator();

        Deft.Chain.pipeline([
            function() {
                me.setLoading("Counting data...");
                return me.validator.getGridData();
            }
        ]).then({
            scope: this,
            success: function(results) {
                this.logger.log('_loadData results', results);
                this._buildGrid(results);
            },
            failure: function(msg) {
                Ext.Msg.alert('Problem loading data', msg);
            }
        }).always(function() { me.setLoading(false); });
    },
    getRules: function(){
        return Ext.Array.merge(
            CA.technicalservices.dataquality.common.Rules.rulesConfig,
            CA.technicalservices.dataquality.common.Rules.drilldownRules
        );
    },
    getHeaderClassesByLabel: function(){
        var headerCls = {};
        Ext.Array.each(this.getRules(), function(rule){
            if (rule.flagYellow){
                headerCls[rule.label] = "dashboard-yellow";
            }
            if (rule.flagRed){
                headerCls[rule.label] = "dashboard-red";
            }
        });
        return headerCls;
    },
    _buildGrid: function(data){

        if (!data || data.length === 0){
            Rally.ui.notify.Notifier.showMessage({message: "No data to display."});
            return;
        }

        var fields = Ext.Object.getKeys(data[0]),
            headerCls = this.getHeaderClassesByLabel();

        var store = Ext.create('Rally.data.custom.Store',{
            data: data,
            fields: fields
        });

        var columnCfgs = [{
            dataIndex: 'bucket',
            text: 'Team',
            flex: 1
        }];

        Ext.Array.each(fields, function(f){
            if (f !== 'bucket' && f !== 'bucketID') {

                var hcls = '';
                if (headerCls[f]){
                    hcls = headerCls[f] + ' ';
                }

                columnCfgs.push({
                    dataIndex: f,
                    cls: hcls + "drilldown",
                    text: f,
                    renderer: function(v,m){
                        m.tdCls = 'drilldown';
                        return v.value;
                    },
                   // cls: 'drilldown',
                    doSort: function(direction){
                        var ds = this.up('rallygrid').getStore();
                        ds.sort({
                            property: f,
                            direction: direction,
                            sorterFn: function(v1, v2){
                                var a = v1.get(f) && v1.get(f).value || 0,
                                    b = v2.get(f) && v2.get(f).value || 0;
                                return a > b ? 1 : (a < b ? -1 : 0);
                            }
                        });
                    }
                });
            }
        });
        this.getGridBox().removeAll();
        this.getGridBox().add({
            xtype: 'rallygrid',
            store: store,
            margin: 20,
            columnCfgs: columnCfgs,
            showPagingToolbar: false,
            showRowActionsColumn: false,
            viewConfig: {
                listeners: {
                    cellclick: this.showDetails,
                    scope: this
                }
            }
        });

    },
    getDetailBox: function(){
        return this.down('#detail_box');
    },
    getGridBox: function(){
        return this.down('#grid_box');
    },
    _createValidator: function() {

        var rules = Ext.Array.merge(
            CA.technicalservices.dataquality.common.Rules.rulesConfig,
            CA.technicalservices.dataquality.common.Rules.drilldownRules
        );
        this.logger.log('_createValidator', rules);
        var validator = Ext.create('CA.techservices.validator.Validator',{
            rules: rules,
            projectUtility: this.projectUtility,
            currentProject: this.getContext().getProject().ObjectID,
            fetchFields: ['FormattedID','ObjectID','Project']
        });
        return validator;
    },
    showDetails: function(view, cell, cellIndex, record) {
        this.logger.log('showDetails', view, record);

        var clickedDataIndex = view.panel.headerCt.getHeaderAtIndex(cellIndex).dataIndex;
        var ruleValue = record.get(clickedDataIndex);

        if (!Ext.isObject(ruleValue)){
            return;
        }
        this.addDetailGrid(record, ruleValue);
    },
    addDetailGrid: function(record, ruleValue){

        var projectID = record.get('bucketID'),
            projectName = record.get('bucket'),
            rule = this.validator.getRule(ruleValue);

        this.logger.log('addDetailGrid');

        this.getDetailBox().removeAll();

        var panelConfig = {
            xtype:'panel',
            ui: 'info-box',
            hideCollapseTool: true,
            collapsible: true,
            collapsed: false,
            collapseDirection: 'right',
            headerPosition: 'left',
            header: true,
            cls: 'detail-panel',
            width: this.getWidth(),
            height: this.getHeight(),
            padding: 10,
            overflowY: 'auto',
            items: [{
                xtype: 'container',
                flex: 1,
                layout: 'hbox',
                items: [{
                    xtype: 'rallybutton',
                    cls: 'detail-collapse-button icon-leave',
                    width: 18,
                    margin: '0 10 0 25',
                    userAction: 'Close (X) filter panel clicked',
                    listeners: {
                        click: function() { this.up('panel').destroy(); }
                    }
                },{
                    xtype: 'container',
                    flex: 1,
                    html: Ext.String.format('<div class="rule-title">{0}: {1}  ({3} results)</div><div class="rule-description">{2}</div>',projectName, rule.getLabel(),rule.getDescription(), ruleValue.value)
                }]
            }]
        };

        if (rule.getUseRallyGrid()){
            this.addDetailRallyGrid(rule, projectID, panelConfig)
        } else {
            this.addDetailGridboard(rule, projectID, panelConfig, ruleValue.id);
        }
    },
    addDetailRallyGrid: function(rule,projectID, panelConfig){
        panelConfig.items.push({
            xtype: 'rallygrid',
            width: '75%',
            storeConfig: {
                model: rule.getModel(),
                fetch: rule.getDetailFetchFields(),
                filters: rule.getDetailFilters(projectID, this.projectUtility),
                enablePostGet: true
            },
            columnCfgs: rule.getDetailColumnCfgs()
        });
        this.getDetailBox().add(panelConfig);
    },
    addDetailGridboard: function(rule,projectID,panelConfig,ruleId){
        var context = this.getContext(),
            projectRef = '/project/' + projectID,
            filters = rule.getDetailFilters(projectID, this.projectUtility),
            fetch = rule.getDetailFetchFields(),
            modelNames = [rule.getModel()];

        this.logger.log('addDetailGridboard', filters.toString(), fetch, modelNames, rule.getDetailColumnCfgs());

        Ext.create('Rally.data.wsapi.TreeStoreBuilder').build({
            models: modelNames,
            enableHierarchy: false,
            fetch: fetch,
            filters: filters,
            enableRootLevelPostGet: true,
            context: {
                project: projectRef,
                projectScopeDown: true
            }
        }).then({
            success: function(store) {
                panelConfig.items.push({
                    xtype: 'rallygridboard',
                    context: context,
                    modelNames: modelNames,
                    toggleState: 'grid',
                    plugins: [{
                        ptype: 'rallygridboardinlinefiltercontrol',
                        inlineFilterButtonConfig: {
                            stateful: true,
                            stateId: context.getScopedStateId('filter-' + ruleId),
                            modelNames: modelNames,
                            inlineFilterPanelConfig: {
                                quickFilterPanelConfig: {
                                    defaultFields: [
                                        'ArtifactSearch',
                                        'Owner',
                                        'Project'
                                    ]
                                }
                            }
                        }
                    },{
                        ptype: 'rallygridboardfieldpicker',
                        headerPosition: 'left',
                        modelNames: modelNames,
                        stateful: true,
                        stateId: context.getScopedStateId('columns-' + ruleId)
                    },{
                        ptype: 'rallygridboardactionsmenu',
                        menuItems: [
                            {
                                text: 'Export...',
                                handler: function() {
                                    window.location = Rally.ui.gridboard.Export.buildCsvExportUrl(
                                        this.down('rallygridboard').getGridOrBoard());
                                },
                                scope: this
                            }
                        ],
                        buttonConfig: {
                            iconCls: 'icon-export'
                        }
                    }],
                    gridConfig: {
                        store: store,
                        storeConfig: {
                            filters: filters,
                            pageSize: 1000,
                            enableRanking: false,
                            enableRootLevelPostGet: true,
                            context: {
                                project: projectRef,
                                projectScopeDown: true
                            }
                        },
                        columnCfgs: rule.getDetailColumnCfgs()
                    },
                    height: this.getHeight()
                });
                this.getDetailBox().add(panelConfig);
            },
            scope: this
        });
    },
    getOptions: function() {
        return [
            {
                text: 'About...',
                handler: this._launchInfo,
                scope: this
            }
        ];
    },
    _launchInfo: function() {
        if ( this.about_dialog ) { this.about_dialog.destroy(); }
        this.about_dialog = Ext.create('Rally.technicalservices.InfoLink',{});
    },
    isExternal: function(){
        return typeof(this.getAppId()) == 'undefined';
    }
});

            
               Rally.launchApp('data-exception-summary', {
                   name: 'Data Exception Drilldown App'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}

.rule-title {
    color: #222222;
    font-family: ProximaNovaSemiBold, Helvetica, Arial;
    font-size: 14px;
    padding-top: 5px;
}

.rule-description {
    bottom: 7px;
    color: #888888;
    font-family: ProximaNova, Helvetica, Arial;
    font-size: 11px;
    width: 100%;
}

.detail-panel {
    border-left-style: solid;
    border-left-width: 5px;
    border-left-color: #d6d6d6;
}

.detail-collapse-button {
    background-color: transparent;
    color: #a9a9a9;
    font-size: 16px;
    line-height: 12px;
    vertical-align: middle;
    margin: 10px 0 0 0;
    padding: 10px 0 0 0;
    right: 8px;
    top: 16px;
    z-index: 2;
}

.rally-grid .drilldown .x-grid-cell-inner:hover {
    color:#00a9e0!important;
    cursor: pointer!important;
    font-family: ProximaNovaBold, Helvetica, Arial;
    font-size: 12px;
}
.x-column-header.dashboard-red {
    background-color: #F2D3D0;
    color: #B81B10;
}
.x-column-header.dashboard-green {
    background-color: #e3f9e9;
    color: #1E7C00;
}
.x-column-header.dashboard-yellow {
    background-color: #FFEDBF;
    color: #FF8200;
}
    </style>

</head>
<body></body>
</html>