<!DOCTYPE html>
<html>
<head>
    <title>Data Quality Dashboard</title>
    <!--  (c) 2016 CA Technologies.  All Rights Reserved. -->
    <!--  Build Date: Thu Nov 10 2016 13:05:20 GMT-0700 (MST) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Thu Nov 10 2016 13:05:20 GMT-0700 (MST)";
        var BUILDER = "kcorkan";
        var CHECKSUM = 43471466271;
    </script>
    
    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350,
    
    informationalConfig: null,
    
    items: [{xtype:'container', itemId:'information' }],
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/var BUILDER = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
       
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
   
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    var stored_checksum = me._generateChecksum(text);
                    if ( CHECKSUM !== stored_checksum ) {
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    _addToContainer: function(container){
        var config = Ext.apply({
            xtype:'container',
            height: 200,
            overflowY: true
        }, this.informationalConfig);
        
        container.add(config);
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if ( !Ext.isEmpty( this.informationalConfig ) ) {
            var container = this.down('#information');
            this._addToContainer(container);
            
        }
        
        if (! app.isExternal() ) {
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            dock: 'bottom',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                },
                failure: function(msg){
                    console.log("oops:",msg);
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml,
                doc: 'top'
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            dock:'bottom',
            html:"This app was created by the CA AC Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html: Ext.String.format("Build date/time: {0} ({1})",
                    APP_BUILD_DATE,
                    BUILDER)
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('CA.technicalservices.dataquality.common.BaseRule',{
    extend: 'Ext.Base',
    alias:  'widget.tsrule_base',
    /*
     * [{Rally.wsapi.data.Model}] portfolioItemTypes the list of PIs available
     * we're going to use the first level ones (different workspaces name their portfolio item levels differently)
     */
    portfolioItemTypes:[],
    /**
     *
     * @cfg
     * {String} model The name of a record type that this rule applies to
     */
    model: null,
    /**
     *
     * @cfg {String} a human-readable label for the chart that will be made from the rule
     */
    label: 'No label supplied for this rule',

    description: 'This is a description for the base rule',

    query: null,

    baseQuery: null,

    fetchFields: null,

    detailFetchFields: null,

    constructor: function(config) {
        console.log('beforeconfig', config, this);
        this.initialConfig = config;
        Ext.apply(this,config);
        console.log('afterconfig', config, this);
    },
    getFeatureName: function(){
        return this.portfolioItemTypes && this.portfolioItemTypes.length > 1 &&
            this.portfolioItemTypes[0].TypePath.replace('PortfolioItem/','');
    },
    getDescription: function() {
        return this.description;
    },
    getFetchFields: function() {
        return this.fetchFields || ['FormattedID'];
    },
    getDetailFetchFields: function(){
        return this.detailFetchFields || this.getFetchFields();
    },
    getLabel: function() {
        return this.label;
    },
    getModel: function() {
        return this.model;
    },
    getConfig: function(){
        return this.initialConfig;
    },
    getCountConfig: function(){
        return {
            model: this.getModel(),
            fetch: this.getFetchFields(),
            filters: this.getFilters()
        };
    },
    getTotalCountConfig: function(){
        return {
            model: this.getModel(),
            fetch: ['ObjectID'],
            filters: this.getBaseFilters()
        };
    },
    getBaseFilters: function(){

        if (this.baseQuery){
            return Rally.data.wsapi.Filter.fromQueryString(this.baseQuery);
        }

        return Ext.create('Rally.data.wsapi.Filter', {
            property:'ObjectID',
            operator:'>',
            value: 0
        });
    },
    getFilters: function() {
        if (this.query){
            return Rally.data.wsapi.Filter.fromQueryString(this.query);
        }
        return Ext.create('Rally.data.wsapi.Filter', {
            property:'ObjectID',
            operator:'>',
            value: 0
        });
    }
});
/**
 * Created by kcorkan on 11/4/16.
 */
Ext.define('recordHolder',{
    data: {},
    constructor: function(config) {
        Ext.apply(this, config);
    },

    get: function(field) {
        return this.data[field];
    }
});

Ext.define('Rally.technicalservices.FileUtilities', {
    singleton: true,
    logger: new Rally.technicalservices.Logger(),

    saveCSVToFile:function(csv,file_name,type_object){
        if (type_object === undefined){
            type_object = {type:'text/csv;charset=utf-8'};
        }
        this.saveAs(csv,file_name, type_object);
    },

    saveAs: function(textToWrite, fileName)
    {
        this.logger.log('saveAs:', fileName);

        if (Ext.isIE9m){
            Rally.ui.notify.Notifier.showWarning({message: "Export is not supported for IE9 and below."});
            return;
        }

        var textFileAsBlob = null;
        try {
            textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});
        }
        catch(e){
            this.logger.log('Caught an error ', e);

            window.BlobBuilder = window.BlobBuilder ||
                window.WebKitBlobBuilder ||
                window.MozBlobBuilder ||
                window.MSBlobBuilder;
            if (window.BlobBuilder ) { //&&  e.name === 'TypeError'){
                bb = new BlobBuilder();
                bb.append([textToWrite]);
                textFileAsBlob = bb.getBlob("text/plain");
            }

        }

        if (!textFileAsBlob){
            Rally.ui.notify.Notifier.showWarning({message: "Export is not supported for this browser."});
            return;
        }

        var fileNameToSaveAs = fileName;

        if (Ext.isIE10p){
            window.navigator.msSaveOrOpenBlob(textFileAsBlob,fileNameToSaveAs); // Now the user will have the option of clicking the Save button and the Open button.
            return;
        }

        var url = this.createObjectURL(textFileAsBlob);

        if (url){
            var downloadLink = document.createElement("a");
            if ("download" in downloadLink){
                downloadLink.download = fileNameToSaveAs;
            } else {
                //Open the file in a new tab
                downloadLink.target = "_blank";
            }

            downloadLink.innerHTML = "Download File";
            downloadLink.href = url;
            if (!Ext.isChrome){
                // Firefox requires the link to be added to the DOM
                // before it can be clicked.
                downloadLink.onclick = this.destroyClickedElement;
                downloadLink.style.display = "none";
                document.body.appendChild(downloadLink);
            }
            downloadLink.click();
        } else {
            Rally.ui.notify.Notifier.showError({message: "Export is not supported "});
        }

    },
    createObjectURL: function ( file ) {
        if ( window.webkitURL ) {
            return window.webkitURL.createObjectURL( file );
        } else if ( window.URL && window.URL.createObjectURL ) {
            return window.URL.createObjectURL( file );
        } else {
            return null;
        }
    },
    saveTextAsFile: function(textToWrite, fileName) {
        var textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});
        var fileNameToSaveAs = fileName;

        var downloadLink = document.createElement("a");
        downloadLink.download = fileNameToSaveAs;
        downloadLink.innerHTML = "Download File";
        if (window.webkitURL != null)
        {
            // Chrome allows the link to be clicked
            // without actually adding it to the DOM.
            downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
        }
        else
        {
            // Firefox requires the link to be added to the DOM
            // before it can be clicked.
            downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
            downloadLink.onclick = destroyClickedElement;
            downloadLink.style.display = "none";
            document.body.appendChild(downloadLink);
        }
        downloadLink.click();
    },
    destroyClickedElement: function(event)
    {
        document.body.removeChild(event.target);
    },
    convertDataArrayToCSVText: function(data_array, requestedFieldHash){

        var text = '';
        Ext.each(Object.keys(requestedFieldHash), function(key){
            text += requestedFieldHash[key] + ',';
        });
        text = text.replace(/,$/,'\n');

        Ext.each(data_array, function(d){
            Ext.each(Object.keys(requestedFieldHash), function(key){
                if (d[key]){
                    if (typeof d[key] === 'object'){
                        if (d[key].FormattedID) {
                            text += Ext.String.format("\"{0}\",",d[key].FormattedID );
                        } else if (d[key].Name) {
                            text += Ext.String.format("\"{0}\",",d[key].Name );
                        } else if (!isNaN(Date.parse(d[key]))){
                            text += Ext.String.format("\"{0}\",",Rally.util.DateTime.formatWithDefaultDateTime(d[key]));
                        }else {
                            text += Ext.String.format("\"{0}\",",d[key].toString());
                        }
                    } else {
                        text += Ext.String.format("\"{0}\",",d[key] );
                    }
                } else {
                    text += ',';
                }
            },this);
            text = text.replace(/,$/,'\n');
        },this);
        return text;
    },
    _getCSVFromWsapiBackedGrid: function(grid,skip_headers) {
        var deferred = Ext.create('Deft.Deferred');
        var store = Ext.create('Rally.data.wsapi.Store',{
            fetch: grid.getStore().config.fetch,
            filters: grid.getStore().config.filters,
            model: grid.getStore().config.model,
            pageSize: 200
        });

        var columns = grid.columns;

        var record_count = grid.getStore().getTotalCount(),
            page_size = grid.getStore().pageSize,
            pages = Math.ceil(record_count/page_size),
            promises = [];

        for (var page = 1; page <= pages; page ++ ) {
            promises.push(this.loadStorePage(grid, store, columns, page, pages));
        }
        Deft.Promise.all(promises).then({
            success: function(csvs){
                var csv = [];
                if ( !skip_headers ) {
                    csv.push('"' + this._getHeadersFromGrid(grid).join('","') + '"');
                }
                _.each(csvs, function(c){
                    _.each(c, function(line){
                        csv.push(line);
                    });
                });
                csv = csv.join('\r\n');
                deferred.resolve(csv);
                Rally.getApp().setLoading(false);
            }
        });
        return deferred.promise;
    },

    getCSVFromRows: function(scope, grid, rows) {
        var me = this;
        var columns = grid.columns;
        var store = grid.getStore();

        console.log('getCSVFromRows');

        var model = grid.model;

        var csv = [];

        csv.push('"' + this._getHeadersFromGrid(grid).join('","') + '"');

        Ext.Array.each(rows,function(row){

            csv.push( me._getCSVFromRecord(Ext.create('recordHolder', { data:row}), grid, store) );
        });

        csv = csv.join('\r\n');
        return csv;
    },

    // custom grid assumes there store is fully loaded
    _getCSVFromCustomBackedGrid: function(grid, skip_headers) {
        var deferred = Ext.create('Deft.Deferred');
        var store = Ext.clone( grid.getStore() );
        var columns = grid.columns;
        Rally.getApp().setLoading("Generating CSV...");

        var record_count = store.getTotalCount(),
            page_size = store.pageSize,
            pages = Math.ceil(record_count/page_size),
            promises = [];

        for (var page = 1; page <= pages; page ++ ) {
            promises.push(this.loadStorePage(grid, store, columns, page, pages));
        }

        Deft.Promise.all(promises).then({
            scope: this,
            success: function(csvs){
                var csv = [];
                if ( !skip_headers ) {
                    csv.push('"' + this._getHeadersFromGrid(grid).join('","') + '"');
                }
                _.each(csvs, function(c){
                    _.each(c, function(line){
                        csv.push(line);
                    });
                });
                csv = csv.join('\r\n');
                deferred.resolve(csv);
                Rally.getApp().setLoading(false);
            }
        });
        return deferred.promise;
    },

    _getHeadersFromGrid: function(grid) {
        var headers = [];
        var columns = grid.columns;

        Ext.Array.each(columns,function(column){
            if ( column.hidden ) { return; }

            if ( column.dataIndex || column.renderer ) {
                if ( column.csvText ) {
                    headers.push(column.csvText.replace('&nbsp;',' '));
                } else if ( column.text )  {
                    headers.push(column.text.replace('&nbsp;',' '));
                }
            }
        });

        return headers;
    },

    _getColumnNamesFromGrid: function(grid) {
        var names = [];
        var columns = grid.columns;

        Ext.Array.each(columns,function(column){
            if ( column.dataIndex || column.renderer ) {
                names.push(column.dataIndex);
            }
        });

        return names;
    },
    /*
     * will render using your grid renderer.  If you want it to ignore the grid renderer,
     * have the column set _csvIgnoreRender: true
     */
    getCSVFromGrid:function(app, grid, skip_headers){
        this.logger.log("Exporting grid with store type:", Ext.getClassName(grid.getStore()));

        if ( Ext.getClassName(grid.getStore()) != "Rally.data.custom.Store" ) {
            return this._getCSVFromWsapiBackedGrid(grid,skip_headers);
        }

        return this._getCSVFromCustomBackedGrid(grid,skip_headers);
    },
    loadStorePage: function(grid, store, columns, page, total_pages){
        var deferred = Ext.create('Deft.Deferred');
        this.logger.log('loadStorePage',page, total_pages);

        store.loadPage(page, {
            callback: function (records) {
                var csv = [];
                Rally.getApp().setLoading(Ext.String.format('Page {0} of {1} loaded',page, total_pages));
                for (var i = 0; i < records.length; i++) {
                    var record = records[i];
                    csv.push( this._getCSVFromRecord(record, grid, store) );
                }
                deferred.resolve(csv);
            },
            scope: this
        });
        return deferred;
    },

    _getCSVFromRecord: function(record, grid, store) {
        //console.log('record:', record);

        var mock_meta_data = {
            align: "right",
            classes: [],
            cellIndex: 9,
            column: null,
            columnIndex: 9,
            innerCls: undefined,
            recordIndex: 5,
            rowIndex: 5,
            style: "",
            tdAttr: "",
            tdCls: "x-grid-cell x-grid-td x-grid-cell-headerId-gridcolumn-1029 x-grid-cell-last x-unselectable",
            unselectableAttr: "unselectable='on'"
        };

        var node_values = [];
        var columns = grid.columns;

        Ext.Array.each(columns, function (column) {
            if (column.xtype == 'rallyrowactioncolumn'  || column.xtype == 'tsrowactioncolumn') {
                return;
            }

            if ( column.hidden ) {
                return;
            }

            if (column.dataIndex) {
                var column_name = column.dataIndex;

                var display_value = record.get(column_name);

                if (!column._csvIgnoreRender && ( column.renderer || column.exportRenderer) ) {
                    if (column.exportRenderer) {
                        display_value = column.exportRenderer(display_value, mock_meta_data, record, 0, 0, store, grid.getView());
                    } else {
                        display_value = column.renderer(display_value, mock_meta_data, record, 0, 0, store, grid.getView());
                    }
                }
                node_values.push(display_value);
            } else {
                var display_value = null;
                if (!column._csvIgnoreRender && column.renderer) {
                    if (column.exportRenderer) {
                        display_value = column.exportRenderer(display_value, mock_meta_data, record, record, 0, 0, store, grid.getView());
                    } else {
                        display_value = column.renderer(display_value, mock_meta_data, record, record, 0, 0, store, grid.getView());
                    }
                    node_values.push(display_value);
                }
            }
        }, this);

        var csv_string = "";
        Ext.Array.each(node_values, function(node_value,idx){
            if ( idx > 0 ) {
                csv_string = csv_string + ",";
            }
            if (/^=/.test(node_value) ) {
                csv_string = csv_string + node_value;
            } else {
                csv_string = csv_string + '"' + node_value + '"';
            }

        });

        return csv_string;
    }

});
Ext.define('CA.technicalservices.dataquality.common.Rules',{
    singleton: true,

    prettyDashboardColumns: 4,
    prettyThreshholdGreen: 10,
    prettyThreshholdYellow: 20,

    rulesConfig: [{

        label: 'Orphaned Features',
        description: 'Counting only features identified as Build',
        model: 'PortfolioItem/Feature',
        unitLabel: 'features',
        query: '((Parent = null) AND (InvestmentCategory = "Build"))',
        detailFetchFields: ['FormattedID','Name','Parent','State']

    },{

        label: 'Orphaned Stories',
        description: 'Counting stories where:<br><li>Assigned Team a build percent != 0 (is > 0 or null). ' +
        '<li>Story is not in "Unelaborated" ScheduleState ' +
        '<li>Story Type is "Standard" or null' +
        '<li>Story has no Feature',
        unitLabel: 'stories',
        model: 'HierarchicalRequirement',
        detailFetchFields: ['FormattedID','Name','Feature','Parent','ScheduleState','c_StoryType'],
        query: '(((c_StoryType = "Standard") OR (c_StoryType = "")) AND (((Feature = null) AND (ScheduleState > "Unelaborated")) AND (Project.c_BuildPercent != 0)))'

    },{

        label: 'Stories not sized',
        description: 'Counting stories where:<br><li>Assigned Team a build percent != 0 (is > 0 or null). ' +
        '<li>Parent Initiative has an Investment Category = "Build" ' +
        '<li>Parent Initiative state is "In-Progress" or "Staging" ' +
        '<li>Story schedule state is in "Defined", "In-Progress" or "Complete" ' +
        '<li>Story Plan Estimate is null ',
        unitLabel: 'stories',
        model: 'HierarchicalRequirement',
        detailFetchFields: ['FormattedID','Name','Feature','PlanEstimate','ScheduleState'],
        query: '((((((Feature.Parent.State.Name = "In-Progress") OR (Feature.Parent.State.Name = "Staging") AND (((ScheduleState = "Defined") OR (ScheduleState = "In-Progress")) OR (ScheduleState = "Completed"))) AND (Feature.Parent.InvestmentCategory = "Build")) AND (Project.c_BuildPercent != 0)) AND (PlanEstimate = ""))'

    },{

        label: 'Active Stories / Inactive Initiatives',
        description: 'Counting stories where:<br><li>Assigned Team a build percent != 0 (is > 0 or null). ' +
        '<li>Parent Initiative has an Investment Category = "Build" ' +
        '<li>Parent Initiative is NOT active (state is NOT "In-Progress" or "Staging") ' +
        '<li>Story is active (schedule state is "Defined", "In-Progress" or "Complete") ' ,
        unitLabel: 'stories',
        model: 'HierarchicalRequirement',
        detailFetchFields: ['FormattedID','Name','Feature','ScheduleState'],
        query: '((((Feature.Parent.State.Name != "In-Progress") AND (Feature.Parent.State.Name != "Staging")) AND (((ScheduleState = "Defined") OR (ScheduleState = "In-Progress")) OR (ScheduleState = "Completed")) AND ((c_StoryType = "Standard") OR (c_StoryType = ""))) AND ((Feature.Parent.InvestmentCategory = "Build") AND (Project.c_BuildPercent != 0)))'

    },{

        label: 'Active Stories on Parent Teams',
        description: 'Counting stories where:<br><li>Assigned Team a build percent != 0 (is > 0 or null). ' +
        '<li>Parent Initiative has an Investment Category = "Build" ' +
        '<li>Parent Initiative is active (state is "In-Progress" or "Staging") ' +
        '<li>Story state is active (state is "Defined", "In-Progress" or "Complete") ' ,
        unitLabel: 'stories',
        detailFetchFields: ['FormattedID','Name','Feature','ScheduleState','Project'],
        model: 'HierarchicalRequirement',
        query: '((((Feature.Parent.State.Name = "In-Progress") OR (Feature.Parent.State.Name = "Staging")) AND (((ScheduleState = "Defined") OR (ScheduleState = "In-Progress")) OR (ScheduleState = "Completed"))) AND (((Feature.Parent.InvestmentCategory = "Build") AND (Project.Children.State = "Open")) AND (Project.c_BuildPercent != 0)))'

    },{

        label: 'Strategy Category',
        description: 'Counting initiatives where:<br>' +
        '<li>Initiative has an Investment Category = "Build" ' +
        '<li>Strategy Category is null',
        unitLabel: 'initiatives',
        detailFetchFields: ['FormattedID','Name','State','InvestmentCategory'],
        model: 'PortfolioItem/Initiative',
        query: '((InvestmentCategory = "Build") AND (c_StrategyCategory = ""))'

    },{

        label: 'Active Stories / Team with no people',
        description: 'Counting stories where:<br>' +
        '<li>Initiative has an Investment Category = "Build" ' +
        '<li>Initiative is active (state is "In-Progress" or "Staging") ' +
        '<li>Story state is active (state is "Defined", "In-Progress" or "Complete") ' +
        '<li>Story is on a Team with no Team Members</li>',
        unitLabel: 'stories',
        model: 'HierarchicalRequirement',
        detailFetchFields: ['FormattedID','Name','Feature','ScheduleState','Project'],
        query: '((((Feature.Parent.State.Name = "In-Progress") OR (Feature.Parent.State.Name = "Staging")) AND (((ScheduleState = "Defined") OR (ScheduleState = "In-Progress")) OR (ScheduleState = "Completed"))) AND ((Feature.Parent.InvestmentCategory = "Build") AND (Project.TeamMembers.ObjectID = "null")))'

    },{

        label: 'Features not sized',
        description: 'Counting features where:' +
        '<li>Initiative is Build' +
        '<li>Initiative is active (state is "In-Progress" or "Staging")' +
        '<li>Preliminary Estimate is null',
        model: 'PortfolioItem/Feature',
        unitLabel: 'features',
        detailFetchFields: ['FormattedID','Name','Parent','PreliminaryEstimate','State','Project'],
        query: '((((Parent.State.Name = "In-Progress") OR (Parent.State.Name = "Staging")) AND (Parent.InvestmentCategory = "Build")) AND (PreliminaryEstimate = ""))'
    }],

    //Add rules to this array that you only want on the "Pretty" dashboard and not in the drilldown app
    prettyRules: [{

        label: 'Misaliged Feature / Intiative Investment Category',
        description: 'Counting features where:' +
        '<li>Initiative Investment Category is "Build"' +
        '<li>Initiative is active (state is "In-Progress" or "Staging")' +
        '<li>Feature Investment Category is NOT "Build"',
        model: 'PortfolioItem/Feature',
        unitLabel: 'features',
        detailFetchFields: ['FormattedID','Name','Parent','InvestmentCategory','State','Project'],
        query: '(((((Parent.State.Name = "Elaborate") OR (Parent.State.Name = "In-Progress")) OR (Parent.State.Name = "Staging")) AND (Parent.InvestmentCategory = "Build")) AND (InvestmentCategory != "Build"))'

    }],

    //Add rules to this array that you only want in the "Drilldown App" but not on the "Pretty" dashboard.
    drilldownRules: []

});
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350,
    
    informationalConfig: null,
    
    items: [{xtype:'container', itemId:'information' }],
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/var BUILDER = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
       
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
   
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    var stored_checksum = me._generateChecksum(text);
                    if ( CHECKSUM !== stored_checksum ) {
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    _addToContainer: function(container){
        var config = Ext.apply({
            xtype:'container',
            height: 200,
            overflowY: true
        }, this.informationalConfig);
        
        container.add(config);
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if ( !Ext.isEmpty( this.informationalConfig ) ) {
            var container = this.down('#information');
            this._addToContainer(container);
            
        }
        
        if (! app.isExternal() ) {
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            dock: 'bottom',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                },
                failure: function(msg){
                    console.log("oops:",msg);
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml,
                doc: 'top'
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            dock:'bottom',
            html:"This app was created by the CA AC Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html: Ext.String.format("Build date/time: {0} ({1})",
                    APP_BUILD_DATE,
                    BUILDER)
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('CA.technicalservices.validation.RuleTemplate', {
    extend: 'Ext.XTemplate',

    /**
     * This template expects a set of rules objects in the following format:
     * {
     *   bucket: <Project Name Bucket>
     *   rules: [{
     *      label: <Short rule Label>,
     *      description: <Rule description>,
     *      flaggedCount: <Count of flagged records>,
     *      totalCount: <Count of total records>,
     *      unitLabel: <plural unit label:  e.g. stories, people>
     *   }...]
     * }
     */

    constructor: function(config) {
        var me = this;
        var columns = config.columns || 3;

        this.callParent([
            '<div class="dashboard-header">Financial Reporting Risks - {bucket}</div>',
            '<table class="dashboard-table"><tr>',
            '<tpl for="rules">',
                '<td class="dashboard-box">',
                    '<div class="{[this.getTitleClass(values)]}">{label}</div>',
                    '<div class="dashboard-percent-title">{[this.getPercentString(values)]}</div>',
                    '<div class="dashboard-subtitle">{flaggedCount} {unitLabel} out of {totalCount}</div>',
                    '<div class="dashboard-description">{description}</div>',
                '</td>',
            '<tpl if="this.isRowBreak(xindex)"></tr><tr></tpl>',
            '</tpl>',
            '</tr></table>',
            {
                columns: columns,
                getPercentString: function(values){
                    var percent = this.getPercent(values);
                    if (percent === null){
                        return 'N/A';
                    }
                    return Ext.String.format('{0}%', percent.toFixed(1));
                },
                getPercent: function(values) {
                    return values.totalCount > 0 ? (values.flaggedCount / values.totalCount * 100) : null;
                },
                isRowBreak: function(col){
                    if((col >= this.columns) && (col % this.columns === 0)){
                        return true;
                    }
                    return false;
                },
                getTitleClass: function(values){
                    var percent = this.getPercent(values);

                    if (percent === null){
                        return 'dashboard-top dashboard-gray';
                    }

                    if (percent < CA.technicalservices.dataquality.common.Rules.prettyThreshholdGreen){
                        return 'dashboard-top dashboard-green';
                    }
                    if (percent < CA.technicalservices.dataquality.common.Rules.prettyThreshholdYellow){
                        return 'dashboard-top dashboard-yellow';
                    }
                    return 'dashboard-top dashboard-red';
                }
            }
        ]);
    }
});
Ext.define('CA.technicalservices.validator.Validator',{
    alias: 'widget.tsvalidator',

    logger: new Rally.technicalservices.Logger(),
    /**
     *
     * [{rule}] An array of validation rules
     */
    rules: [],

    constructor: function(config) {
        Ext.apply(this,config);

        var rules = [];

        Ext.Array.each(this.rules, function(rule){
            var name = rule.xtype || 'tsrule_base';
            if ( !Ext.isEmpty(name) ) {
                delete rule.xtype;
                rules.push(Ext.createByAlias('widget.' + name, rule));
            }
        });
        this.logger.log('Validator.constructor', this.rules);
        this.rules = rules;
    },
    run: function(){
        var deferred = Ext.create('Deft.Deferred');
        this.logger.log('run', this.rules);
        var promises = [],
            me = this;
        Ext.Array.each(this.rules, function(rule){
            promises.push(me.updateRule(rule));
        });

        Deft.Promise.all(promises).then({
            success: function(){
                deferred.resolve(this);
            },
            failure: function(msg){
                deferred.reject(msg);
            },
            scope: this
        });

        return deferred;
    },
    updateRule: function(rule){
        var deferred = Ext.create('Deft.Deferred');

        this.logger.log('updateRule', rule.model);
        this.getTotalCount(rule.model).then({
            success: function(totalCount){
                rule.totalCount = totalCount;
                this.logger.log('updateRule.getTotalCount', rule.model, totalCount);

                var config = rule.getCountConfig();
                config.context = {
                    project: this.projectRef,
                    projectScopeDown: true
                };

                this._loadWsapiCount(config).then({
                    success: function(count){
                        this.logger.log('updateRule._loadWsapiCount', rule.getLabel(), count, config);
                        rule.flaggedCount = count;
                        deferred.resolve();
                    },
                    failure: function(msg){
                        deferred.reject(msg);
                    },
                    scope: this
                });
            },
            failure: function(msg){
                deferred.reject(msg);
            },
            scope: this
        });
        return deferred;
    },
    getTotalCount: function(model){
        var deferred = Ext.create('Deft.Deferred');
        if (this.totalCounts && this.totalCounts[model]){
            deferred.resolve(this.totalCounts[model]);
        } else {
            this._loadWsapiCount({
                model: model,
                fetch: ['ObjectID'],
                context: {
                    project: this.projectRef,
                    projectScopeDown: true
                }
            }).then({
                success: function(count){
                    if (!this.totalCounts){
                        this.totalCounts = {};
                    }
                    this.totalCounts[model] = count;
                    deferred.resolve(count);
                },
                failure: function(msg){
                    deferred.reject(msg);
                },
                scope: this
            });
        }
        return deferred;
    },
    getRules: function(){
        return this.rules;
    },
    _loadWsapiRecords: function(config) {
        var deferred = Ext.create('Deft.Deferred');

        Ext.create('Rally.data.wsapi.Store',config).load({
            callback: function(records, operation){
                if (operation.wasSuccessful()){
                    var result = {};
                    result[config.model] = records;
                    deferred.resolve(result);
                } else {
                    deferred.reject(operation.error.errors.join(','));
                }
            }
        });
        return deferred.promise;
    },
    _loadWsapiCount: function(config){
        var deferred = Ext.create('Deft.Deferred');

        config.pageSize = 1;
        config.limit = 1;

        Ext.create('Rally.data.wsapi.Store',config).load({
            callback: function(records, operation){
                if (operation.wasSuccessful()){
                    deferred.resolve(operation.resultSet.totalRecords);
                } else {
                    deferred.reject(operation.error.errors.join(','));
                }
            }
        });
        return deferred.promise;
    }
});
Ext.define("data-quality-dashboard", {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    defaults: { margin: 10 },
    items: [
        {xtype:'container',itemId:'message_box',tpl:'Hello, <tpl>{_refObjectName}</tpl>'},
        {xtype:'container',itemId:'display_box'}
    ],

    integrationHeaders : {
        name : "data-quality-dashboard"
    },

    launch: function() {
        this.createValidator()
    },
    createValidator: function(){

        var rules = Ext.Array.merge(
            CA.technicalservices.dataquality.common.Rules.rulesConfig,
            CA.technicalservices.dataquality.common.Rules.prettyRules
        );
        var validator = Ext.create('CA.technicalservices.validator.Validator',{
            bucket: this.getContext().getProject().Name,
            projectRef: this.getContext().getProject()._ref,
            rules: rules
        });

        this.setLoading(true);
        validator.run().then({
            failure: this.showErrorNotification,
            success: this.displayDashboard,
            scope: this
        }).always(function(){ this.setLoading(false); }, this);
    },
    displayDashboard: function(validator){
        this.removeAll();
        var tpl = Ext.create('CA.technicalservices.validation.RuleTemplate',{
            columns: CA.technicalservices.dataquality.common.Rules.prettyDashboardColumns
        });

        this.add({
            xtype: 'container',
            tpl: tpl,
            margin: '0 100 0 100',
            flex: 1
        }).update(validator);
    },
    showErrorNotification: function(msg){
        this.logger.log('showErrorNotification', msg);
        Rally.ui.notify.Notifier.showError({
            message: msg
        });
    },
    getOptions: function() {
        return [
            {
                text: 'About...',
                handler: this._launchInfo,
                scope: this
            }
        ];
    },
    _launchInfo: function() {
        if ( this.about_dialog ) { this.about_dialog.destroy(); }
        this.about_dialog = Ext.create('Rally.technicalservices.InfoLink',{});
    },
    
    isExternal: function(){
        return typeof(this.getAppId()) == 'undefined';
    },
    //onSettingsUpdate:  Override
    onSettingsUpdate: function (settings){
        this.logger.log('onSettingsUpdate',settings);
        // Ext.apply(this, settings);
        this.launch();
    }
});

            
               Rally.launchApp('data-quality-dashboard', {
                   name: 'Data Quality Dashboard'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}
.dashboard-title {
    width: 100%;
    font-family: ProximaNovaSemiBold, Helvetica, Arial;
    font-size: 14px;
    padding: 5px;
    text-align: center;
}
.dashboard-percent-title {
    font-family: ProximaNovaSemiBold, Helvetica, Arial;
    font-size: 16px;
    text-align: center;
    vertical-align: middle;
    padding: 15px 10px 10px 10px;
}
.dashboard-subtitle{
    font-family: ProximaNovaSemiBold, Helvetica, Arial;
    font-size: 11px;
    text-align: center;
    padding: 10px;
}
.dashboard-header{
    color: #222222;
    font-family: ProximaNovaSemiBold, Helvetica, Arial;
    font-size: 14px;
    padding: 10px;
    text-align: left;
}
.dashboard-description {
    text-align: left;
    padding: 15px;
    color: #888888;
    font-family: ProximaNova, Helvetica, Arial;
    font-size: 11px;
}
.dashboard-box{
    border-width: 1px;
    border-color: #000;
    border-style: solid;
    vertical-align: top;
    padding: 0px;
    width: 100%;
}

.dashboard-gray {
    background-color: #f6f6f6;
    color: #888;
}

.dashboard-top {
    height: 75px;
    width: 100%;
    font-family: ProximaNovaSemiBold, Helvetica, Arial;
    font-size: 16px;
    text-align: center;
    padding: 15px 10px 10px 10px;
    vertical-align: middle;
}
.dashboard-red {
    background-color: #F2D3D0;
    color: #B81B10;
}
.dashboard-green {
    background-color: #e3f9e9;
    color: #1E7C00;
}
.dashboard-yellow {
    background-color: #FFEDBF;
    color: #FF8200;
}
.dashboard-table {
    border-collapse: collapse;
    border-color: grey;
    width: 100%;
    table-layout: fixed;
}
    </style>

</head>
<body></body>
</html>