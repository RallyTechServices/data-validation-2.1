<!DOCTYPE html>
<html>
<head>
    <title>Data Quality Dashboard</title>
    <!--  (c) 2016 CA Technologies.  All Rights Reserved. -->
    <!--  Build Date: Fri Jan 20 2017 16:58:00 GMT-0700 (MST) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Fri Jan 20 2017 16:58:00 GMT-0700 (MST)";
        var BUILDER = "kcorkan";
        var CHECKSUM = 56895690842;
    </script>
    
    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350,
    
    informationalConfig: null,
    
    items: [{xtype:'container', itemId:'information' }],
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/var BUILDER = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
       
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
   
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    var stored_checksum = me._generateChecksum(text);
                    if ( CHECKSUM !== stored_checksum ) {
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    _addToContainer: function(container){
        var config = Ext.apply({
            xtype:'container',
            height: 200,
            overflowY: true
        }, this.informationalConfig);
        
        container.add(config);
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if ( !Ext.isEmpty( this.informationalConfig ) ) {
            var container = this.down('#information');
            this._addToContainer(container);
            
        }
        
        if (! app.isExternal() ) {
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            dock: 'bottom',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                },
                failure: function(msg){
                    console.log("oops:",msg);
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml,
                doc: 'top'
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            dock:'bottom',
            html:"This app was created by the CA AC Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html: Ext.String.format("Build date/time: {0} ({1})",
                    APP_BUILD_DATE,
                    BUILDER)
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('CA.technicalservices.dataquality.common.BaseRule',{
    extend: 'Ext.Base',
    alias:  'widget.tsrule_base',
    /*
     * [{Rally.wsapi.data.Model}] portfolioItemTypes the list of PIs available
     * we're going to use the first level ones (different workspaces name their portfolio item levels differently)
     */
    portfolioItemTypes:[],
    /**
     *
     * @cfg
     * {String} model The name of a record type that this rule applies to
     */
    model: null,
    /**
     *
     * @cfg {String} a human-readable label for the chart that will be made from the rule
     */
    label: 'No label supplied for this rule',

    description: 'This is a description for the base rule',

    query: null,

    baseQuery: null,

    fetchFields: null,

    detailFetchFields: null,

    constructor: function(config) {
        this.initialConfig = config;
        Ext.apply(this,config);
    },
    getUseRallyGrid: function(){
        return false;
    },
    getFeatureName: function(){
        return this.portfolioItemTypes && this.portfolioItemTypes.length > 1 &&
            this.portfolioItemTypes[0].TypePath.replace('PortfolioItem/','');
    },
    getDescription: function() {
        return this.description;
    },
    getFetchFields: function() {
        return this.fetchFields || ['FormattedID'];
    },
    getDetailFetchFields: function(){
        return this.detailFetchFields || this.getFetchFields();
    },
    getLabel: function() {
        return this.label;
    },
    getModel: function() {
        return this.model;
    },
    getConfig: function(){
        return this.initialConfig;
    },
    getCountConfig: function(){
        return {
            model: this.getModel(),
            fetch: this.getFetchFields(),
            filters: this.getFilters()
        };
    },
    getTotalCountConfig: function(){
        return {
            model: this.getModel(),
            fetch: ['ObjectID'],
            filters: this.getBaseFilters()
        };
    },
    getBaseFilters: function(){

        if (this.baseQuery){
            return Rally.data.wsapi.Filter.fromQueryString(this.baseQuery);
        }

        return Ext.create('Rally.data.wsapi.Filter', {
            property:'ObjectID',
            operator:'>',
            value: 0
        });
    },
    getFilters: function() {
        if (this.query){
            return Rally.data.wsapi.Filter.fromQueryString(this.query);
        }
        return Ext.create('Rally.data.wsapi.Filter', {
            property:'ObjectID',
            operator:'>',
            value: 0
        });
    },
    getDetailFilters: function(){
        return this.getFilters();
    },
    getDetailColumnCfgs: function(){
        return this.getDetailFetchFields();
    },
    _loadWsapiRecords: function(config) {
        var deferred = Ext.create('Deft.Deferred');

        Ext.create('Rally.data.wsapi.Store',config).load({
            callback: function(records, operation){
                if (operation.wasSuccessful()){
                    var result = {};
                    result[config.model] = records;
                    deferred.resolve(records);
                } else {
                    deferred.reject(operation.error.errors.join(','));
                }
            }
        });
        return deferred.promise;
    }
});
Ext.define('CA.technicalservices.dataquality.common.LeafProjectBuildPercentRule',{
    extend: 'CA.technicalservices.dataquality.common.BaseRule',
    alias:  'widget.rule_leafprojectbuildpercentrule',

    getUseRallyGrid: function(){
        return true;
    },
    getCount: function(projectID, projectUtility){
        var deferred = Ext.create('Deft.Deferred');

        if (this.recordData){
            var count = this._processRecords(projectID, projectUtility).length;
            deferred.resolve(count);
        } else {
            var projectRef= '/project/' + projectID,
                config = {
                    model: this.getModel(),
                    fetch: this.getFetchFields(),
                    filters: this.getFilters(),
                    context: {project: projectRef, projectScopeDown: true},
                    limit: Infinity
                };

            this._loadWsapiRecords(config).then({
                success: function(records){
                    this.recordData = _.map(records, function(r){ return r.getData(); });
                    var count = this._processRecords(projectID, projectUtility).length;
                    deferred.resolve(count);
                },
                scope: this
            });
        }
        return deferred;
    },
    _processRecords: function(projectID,projectUtility){
        var children = projectUtility.getAllChildren(projectID),
            oids = [];

        Ext.Array.each(this.recordData, function(r){
            if (Ext.Array.contains(children, r.ObjectID)){
                oids.push(r.ObjectID);
            }
        });

       return oids;
    },
    getDetailFilters: function(projectID, projectUtility){
        var oids = this._processRecords(projectID, projectUtility);
        var filters = Ext.Array.map(oids, function(o){ return {
                property: 'ObjectID',
                value: o
            };
        });
        if (filters && filters.length > 1){
            return Rally.data.wsapi.Filter.or(filters);
        }
        return filters;

    },
    getDetailColumnConfigs: function(){
        return [{
            dataIndex: 'Name',
            text: 'Name'
        },{
            dataIndex: 'c_BuildPercent',
            text: 'Build Percent'
        }]
    }
});
Ext.define('CA.technicalservices.dataquality.common.TeamAssignmentInconsistency',{
    extend: 'CA.technicalservices.dataquality.common.BaseRule',
    alias:  'widget.rule_teamassignmentinconsistency',
    getCount: function(projectID, projectUtility){
        var deferred = Ext.create('Deft.Deferred');

        var projectRef= '/project/' + projectID,
            config = {
                model: this.getModel(),
                fetch: ['ObjectID','Project','Owner','c_WorkdayTeam'],
                filters: this.getFilters(),
                context: {project: projectRef, projectScopeDown: true},
                compact: false,
                pageSize: 2000,
                limit: Infinity
            };

        this._loadWsapiRecords(config).then({
            success: function(records){
                var recordData = _.map(records, function(r){ return r.getData(); }),
                    obj = this._processRecords(recordData);

                if (!this.flaggedItems){
                    this.flaggedItems = {};
                }
                this.flaggedItems[projectID] = obj;

                deferred.resolve(obj.count);
            },
            scope: this
        });
        return deferred;
    },
    _processRecords: function(recordData){
        var flaggedStories = [],
            count = 0;

        for (var i=0; i<recordData.length; i++){
            var r = recordData[i];
            if (Number(r.Owner.c_WorkdayTeam) !== r.Project.ObjectID){
                flaggedStories.push(r.ObjectID);
                count++;
            }
        }
        return {
            count: count,
            flaggedStories: flaggedStories
        };
        //return affectedProjects;
    },
    getDetailFilters: function(projectID, projectUtility){

        var obj = this.flaggedItems[projectID],
            stories = obj.flaggedStories;

        var filters = Ext.Array.map(stories, function(o){ return {
                property: 'ObjectID',
                value: o
            };
        });

        if (filters && filters.length > 1){
             return Rally.data.wsapi.Filter.or(filters);
        }
        if (filters.length === 0){
            filters = {
                property: 'ObjectID',
                value: 0
            };
        }
        return filters;
    }
});
/**
 * Created by kcorkan on 11/4/16.
 */
Ext.define('recordHolder',{
    data: {},
    constructor: function(config) {
        Ext.apply(this, config);
    },

    get: function(field) {
        return this.data[field];
    }
});

Ext.define('Rally.technicalservices.FileUtilities', {
    singleton: true,
    logger: new Rally.technicalservices.Logger(),

    saveCSVToFile:function(csv,file_name,type_object){
        if (type_object === undefined){
            type_object = {type:'text/csv;charset=utf-8'};
        }
        this.saveAs(csv,file_name, type_object);
    },

    saveAs: function(textToWrite, fileName)
    {
        this.logger.log('saveAs:', fileName);

        if (Ext.isIE9m){
            Rally.ui.notify.Notifier.showWarning({message: "Export is not supported for IE9 and below."});
            return;
        }

        var textFileAsBlob = null;
        try {
            textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});
        }
        catch(e){
            this.logger.log('Caught an error ', e);

            window.BlobBuilder = window.BlobBuilder ||
                window.WebKitBlobBuilder ||
                window.MozBlobBuilder ||
                window.MSBlobBuilder;
            if (window.BlobBuilder ) { //&&  e.name === 'TypeError'){
                bb = new BlobBuilder();
                bb.append([textToWrite]);
                textFileAsBlob = bb.getBlob("text/plain");
            }

        }

        if (!textFileAsBlob){
            Rally.ui.notify.Notifier.showWarning({message: "Export is not supported for this browser."});
            return;
        }

        var fileNameToSaveAs = fileName;

        if (Ext.isIE10p){
            window.navigator.msSaveOrOpenBlob(textFileAsBlob,fileNameToSaveAs); // Now the user will have the option of clicking the Save button and the Open button.
            return;
        }

        var url = this.createObjectURL(textFileAsBlob);

        if (url){
            var downloadLink = document.createElement("a");
            if ("download" in downloadLink){
                downloadLink.download = fileNameToSaveAs;
            } else {
                //Open the file in a new tab
                downloadLink.target = "_blank";
            }

            downloadLink.innerHTML = "Download File";
            downloadLink.href = url;
            if (!Ext.isChrome){
                // Firefox requires the link to be added to the DOM
                // before it can be clicked.
                downloadLink.onclick = this.destroyClickedElement;
                downloadLink.style.display = "none";
                document.body.appendChild(downloadLink);
            }
            downloadLink.click();
        } else {
            Rally.ui.notify.Notifier.showError({message: "Export is not supported "});
        }

    },
    createObjectURL: function ( file ) {
        if ( window.webkitURL ) {
            return window.webkitURL.createObjectURL( file );
        } else if ( window.URL && window.URL.createObjectURL ) {
            return window.URL.createObjectURL( file );
        } else {
            return null;
        }
    },
    saveTextAsFile: function(textToWrite, fileName) {
        var textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});
        var fileNameToSaveAs = fileName;

        var downloadLink = document.createElement("a");
        downloadLink.download = fileNameToSaveAs;
        downloadLink.innerHTML = "Download File";
        if (window.webkitURL != null)
        {
            // Chrome allows the link to be clicked
            // without actually adding it to the DOM.
            downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
        }
        else
        {
            // Firefox requires the link to be added to the DOM
            // before it can be clicked.
            downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
            downloadLink.onclick = destroyClickedElement;
            downloadLink.style.display = "none";
            document.body.appendChild(downloadLink);
        }
        downloadLink.click();
    },
    destroyClickedElement: function(event)
    {
        document.body.removeChild(event.target);
    },
    convertDataArrayToCSVText: function(data_array, requestedFieldHash){

        var text = '';
        Ext.each(Object.keys(requestedFieldHash), function(key){
            text += requestedFieldHash[key] + ',';
        });
        text = text.replace(/,$/,'\n');

        Ext.each(data_array, function(d){
            Ext.each(Object.keys(requestedFieldHash), function(key){
                if (d[key]){
                    if (typeof d[key] === 'object'){
                        if (d[key].FormattedID) {
                            text += Ext.String.format("\"{0}\",",d[key].FormattedID );
                        } else if (d[key].Name) {
                            text += Ext.String.format("\"{0}\",",d[key].Name );
                        } else if (!isNaN(Date.parse(d[key]))){
                            text += Ext.String.format("\"{0}\",",Rally.util.DateTime.formatWithDefaultDateTime(d[key]));
                        }else {
                            text += Ext.String.format("\"{0}\",",d[key].toString());
                        }
                    } else {
                        text += Ext.String.format("\"{0}\",",d[key] );
                    }
                } else {
                    text += ',';
                }
            },this);
            text = text.replace(/,$/,'\n');
        },this);
        return text;
    },
    _getCSVFromWsapiBackedGrid: function(grid,skip_headers) {
        var deferred = Ext.create('Deft.Deferred');
        var store = Ext.create('Rally.data.wsapi.Store',{
            fetch: grid.getStore().config.fetch,
            filters: grid.getStore().config.filters,
            model: grid.getStore().config.model,
            pageSize: 200
        });

        var columns = grid.columns;

        var record_count = grid.getStore().getTotalCount(),
            page_size = grid.getStore().pageSize,
            pages = Math.ceil(record_count/page_size),
            promises = [];

        for (var page = 1; page <= pages; page ++ ) {
            promises.push(this.loadStorePage(grid, store, columns, page, pages));
        }
        Deft.Promise.all(promises).then({
            success: function(csvs){
                var csv = [];
                if ( !skip_headers ) {
                    csv.push('"' + this._getHeadersFromGrid(grid).join('","') + '"');
                }
                _.each(csvs, function(c){
                    _.each(c, function(line){
                        csv.push(line);
                    });
                });
                csv = csv.join('\r\n');
                deferred.resolve(csv);
                Rally.getApp().setLoading(false);
            }
        });
        return deferred.promise;
    },

    getCSVFromRows: function(scope, grid, rows) {
        var me = this;
        var columns = grid.columns;
        var store = grid.getStore();

        console.log('getCSVFromRows');

        var model = grid.model;

        var csv = [];

        csv.push('"' + this._getHeadersFromGrid(grid).join('","') + '"');

        Ext.Array.each(rows,function(row){

            csv.push( me._getCSVFromRecord(Ext.create('recordHolder', { data:row}), grid, store) );
        });

        csv = csv.join('\r\n');
        return csv;
    },

    // custom grid assumes there store is fully loaded
    _getCSVFromCustomBackedGrid: function(grid, skip_headers) {
        var deferred = Ext.create('Deft.Deferred');
        var store = Ext.clone( grid.getStore() );
        var columns = grid.columns;
        Rally.getApp().setLoading("Generating CSV...");

        var record_count = store.getTotalCount(),
            page_size = store.pageSize,
            pages = Math.ceil(record_count/page_size),
            promises = [];

        for (var page = 1; page <= pages; page ++ ) {
            promises.push(this.loadStorePage(grid, store, columns, page, pages));
        }

        Deft.Promise.all(promises).then({
            scope: this,
            success: function(csvs){
                var csv = [];
                if ( !skip_headers ) {
                    csv.push('"' + this._getHeadersFromGrid(grid).join('","') + '"');
                }
                _.each(csvs, function(c){
                    _.each(c, function(line){
                        csv.push(line);
                    });
                });
                csv = csv.join('\r\n');
                deferred.resolve(csv);
                Rally.getApp().setLoading(false);
            }
        });
        return deferred.promise;
    },

    _getHeadersFromGrid: function(grid) {
        var headers = [];
        var columns = grid.columns;

        Ext.Array.each(columns,function(column){
            if ( column.hidden ) { return; }

            if ( column.dataIndex || column.renderer ) {
                if ( column.csvText ) {
                    headers.push(column.csvText.replace('&nbsp;',' '));
                } else if ( column.text )  {
                    headers.push(column.text.replace('&nbsp;',' '));
                }
            }
        });

        return headers;
    },

    _getColumnNamesFromGrid: function(grid) {
        var names = [];
        var columns = grid.columns;

        Ext.Array.each(columns,function(column){
            if ( column.dataIndex || column.renderer ) {
                names.push(column.dataIndex);
            }
        });

        return names;
    },
    /*
     * will render using your grid renderer.  If you want it to ignore the grid renderer,
     * have the column set _csvIgnoreRender: true
     */
    getCSVFromGrid:function(app, grid, skip_headers){
        this.logger.log("Exporting grid with store type:", Ext.getClassName(grid.getStore()));

        if ( Ext.getClassName(grid.getStore()) != "Rally.data.custom.Store" ) {
            return this._getCSVFromWsapiBackedGrid(grid,skip_headers);
        }

        return this._getCSVFromCustomBackedGrid(grid,skip_headers);
    },
    loadStorePage: function(grid, store, columns, page, total_pages){
        var deferred = Ext.create('Deft.Deferred');
        this.logger.log('loadStorePage',page, total_pages);

        store.loadPage(page, {
            callback: function (records) {
                var csv = [];
                Rally.getApp().setLoading(Ext.String.format('Page {0} of {1} loaded',page, total_pages));
                for (var i = 0; i < records.length; i++) {
                    var record = records[i];
                    csv.push( this._getCSVFromRecord(record, grid, store) );
                }
                deferred.resolve(csv);
            },
            scope: this
        });
        return deferred;
    },

    _getCSVFromRecord: function(record, grid, store) {
        //console.log('record:', record);

        var mock_meta_data = {
            align: "right",
            classes: [],
            cellIndex: 9,
            column: null,
            columnIndex: 9,
            innerCls: undefined,
            recordIndex: 5,
            rowIndex: 5,
            style: "",
            tdAttr: "",
            tdCls: "x-grid-cell x-grid-td x-grid-cell-headerId-gridcolumn-1029 x-grid-cell-last x-unselectable",
            unselectableAttr: "unselectable='on'"
        };

        var node_values = [];
        var columns = grid.columns;

        Ext.Array.each(columns, function (column) {
            if (column.xtype == 'rallyrowactioncolumn'  || column.xtype == 'tsrowactioncolumn') {
                return;
            }

            if ( column.hidden ) {
                return;
            }

            if (column.dataIndex) {
                var column_name = column.dataIndex;

                var display_value = record.get(column_name);

                if (!column._csvIgnoreRender && ( column.renderer || column.exportRenderer) ) {
                    if (column.exportRenderer) {
                        display_value = column.exportRenderer(display_value, mock_meta_data, record, 0, 0, store, grid.getView());
                    } else {
                        display_value = column.renderer(display_value, mock_meta_data, record, 0, 0, store, grid.getView());
                    }
                }
                node_values.push(display_value);
            } else {
                var display_value = null;
                if (!column._csvIgnoreRender && column.renderer) {
                    if (column.exportRenderer) {
                        display_value = column.exportRenderer(display_value, mock_meta_data, record, record, 0, 0, store, grid.getView());
                    } else {
                        display_value = column.renderer(display_value, mock_meta_data, record, record, 0, 0, store, grid.getView());
                    }
                    node_values.push(display_value);
                }
            }
        }, this);

        var csv_string = "";
        Ext.Array.each(node_values, function(node_value,idx){
            if ( idx > 0 ) {
                csv_string = csv_string + ",";
            }
            if (/^=/.test(node_value) ) {
                csv_string = csv_string + node_value;
            } else {
                csv_string = csv_string + '"' + node_value + '"';
            }

        });

        return csv_string;
    }

});
Ext.define('CA.technicalservices.dataquality.common.Rules',{
    singleton: true,

    prettyDashboardColumns: 4,
    prettyThreshholdGreen: 10,
    prettyThreshholdYellow: 20,

    rulesConfig: [{

        label: 'Orphaned Features',
        description: 'Counting only features identified as Build',
        model: 'PortfolioItem/Feature',
        unitLabel: 'features',
        query: '((Parent = null) AND (InvestmentCategory = "Build"))',
        detailFetchFields: ['FormattedID','Name','Parent','State'],
        flagRed: true,
        flagYellow: false
    },{

        label: 'Orphaned Stories',
        flagRed: false,
        flagYellow: false,
        description: 'Counting stories where:<br><li>Assigned Team a build percent != 0 (is > 0 or null). ' +
        '<li>Story is not in "Unelaborated" ScheduleState ' +
        '<li>Story Type is "Standard" or null' +
        '<li>Story has no Feature',
        unitLabel: 'stories',
        model: 'HierarchicalRequirement',
        detailFetchFields: ['FormattedID','Name','Feature','Parent','ScheduleState','c_StoryType'],
        query: '(((c_StoryType = "Standard") OR (c_StoryType = "")) AND (((Feature = null) AND (ScheduleState > "Unelaborated")) AND (Project.c_BuildPercent != 0)))'
    },{

        label: 'Stories not sized',
        flagRed: false,
        flagYellow: true,
        description: 'Counting stories where:<br><li>Assigned Team a build percent != 0 (is > 0 or null). ' +
        '<li>Parent Initiative has an Investment Category = "Build" ' +
        '<li>Parent Initiative state is "In-Progress" or "Staging" ' +
        '<li>Story schedule state is in "Defined", "In-Progress" or "Complete" ' +
        '<li>Story Plan Estimate is null ',
        unitLabel: 'stories',
        model: 'HierarchicalRequirement',
        detailFetchFields: ['FormattedID','Name','Feature','PlanEstimate','ScheduleState'],
        query: '((((((Feature.Parent.State.Name = "In-Progress") OR (Feature.Parent.State.Name = "Staging") AND (((ScheduleState = "Defined") OR (ScheduleState = "In-Progress")) OR (ScheduleState = "Completed"))) AND (Feature.Parent.InvestmentCategory = "Build")) AND (Project.c_BuildPercent != 0)) AND (PlanEstimate = ""))'

    },{

        label: 'Active Stories / Inactive Initiatives',
        watchColor: null,
        description: 'Counting stories where:<br><li>Assigned Team a build percent != 0 (is > 0 or null). ' +
        '<li>Parent Initiative has an Investment Category = "Build" ' +
        '<li>Parent Initiative is NOT active (state is NOT "In-Progress" or "Staging") ' +
        '<li>Story is active (schedule state is "Defined", "In-Progress" or "Complete") ' ,
        unitLabel: 'stories',
        model: 'HierarchicalRequirement',
        detailFetchFields: ['FormattedID','Name','Feature','ScheduleState'],
        query: '((((Feature.Parent.State.Name != "In-Progress") AND (Feature.Parent.State.Name != "Staging")) AND (((ScheduleState = "Defined") OR (ScheduleState = "In-Progress")) OR (ScheduleState = "Completed")) AND ((c_StoryType = "Standard") OR (c_StoryType = ""))) AND ((Feature.Parent.InvestmentCategory = "Build") AND (Project.c_BuildPercent != 0)))'

    },{

            label: 'Active Stories on Parent Teams',
        watchColor: null,
        description: 'Counting stories where:<br><li>Assigned Team a build percent != 0 (is > 0 or null). ' +
        '<li>Parent Initiative has an Investment Category = "Build" ' +
        '<li>Parent Initiative is active (state is "In-Progress" or "Staging") ' +
        '<li>Story state is active (state is "Defined", "In-Progress" or "Complete") ' ,
        unitLabel: 'stories',
        detailFetchFields: ['FormattedID','Name','Feature','ScheduleState','Project'],
        model: 'HierarchicalRequirement',
        query: '((((Feature.Parent.State.Name = "In-Progress") OR (Feature.Parent.State.Name = "Staging")) AND (((ScheduleState = "Defined") OR (ScheduleState = "In-Progress")) OR (ScheduleState = "Completed"))) AND (((Feature.Parent.InvestmentCategory = "Build") AND (Project.Children.State = "Open")) AND (Project.c_BuildPercent != 0)))'

    },{

        label: 'Strategy Category',
        watchColor: null,
        description: 'Counting initiatives where:<br>' +
        '<li>Initiative has an Investment Category = "Build" ' +
        '<li>Strategy Category is null',
        unitLabel: 'initiatives',
        detailFetchFields: ['FormattedID','Name','State','InvestmentCategory'],
        model: 'PortfolioItem/Initiative',
        query: '((InvestmentCategory = "Build") AND (c_StrategyCategory = ""))'

    },{

        label: 'Active Stories / Team with no people',
        watchColor: null,
        description: 'Counting stories where:<br>' +
        '<li>Initiative has an Investment Category = "Build" ' +
        '<li>Initiative is active (state is "In-Progress" or "Staging") ' +
        '<li>Story state is active (state is "Defined", "In-Progress" or "Complete") ' +
        '<li>Story is on a Team with no Team Members</li>',
        unitLabel: 'stories',
        model: 'HierarchicalRequirement',
        detailFetchFields: ['FormattedID','Name','Feature','ScheduleState','Project'],
        query: '((((Feature.Parent.State.Name = "In-Progress") OR (Feature.Parent.State.Name = "Staging")) AND (((ScheduleState = "Defined") OR (ScheduleState = "In-Progress")) OR (ScheduleState = "Completed"))) AND ((Feature.Parent.InvestmentCategory = "Build") AND (Project.TeamMembers.ObjectID = "null")))'

    },{

        label: 'Features not sized',
        watchColor: null,
        description: 'Counting features where:' +
        '<li>Initiative is Build' +
        '<li>Initiative is active (state is "In-Progress" or "Staging")' +
        '<li>Preliminary Estimate is null',
        model: 'PortfolioItem/Feature',
        unitLabel: 'features',
        detailFetchFields: ['FormattedID','Name','Parent','PreliminaryEstimate','State','Project'],
        query: '((((Parent.State.Name = "In-Progress") OR (Parent.State.Name = "Staging")) AND (Parent.InvestmentCategory = "Build")) AND (PreliminaryEstimate = ""))'
    }],

    //Add rules to this array that you only want on the "Pretty" dashboard and not in the drilldown app
    prettyRules: [{

        label: 'Misaliged Feature / Intiative Investment Category',
        description: 'Counting features where:' +
        '<li>Initiative Investment Category is "Build"' +
        '<li>Initiative is active (state is "In-Progress" or "Staging")' +
        '<li>Feature Investment Category is NOT "Build"',
        model: 'PortfolioItem/Feature',
        unitLabel: 'features',
        detailFetchFields: ['FormattedID','Name','Parent','InvestmentCategory','State','Project'],
        query: '(((((Parent.State.Name = "Elaborate") OR (Parent.State.Name = "In-Progress")) OR (Parent.State.Name = "Staging")) AND (Parent.InvestmentCategory = "Build")) AND (InvestmentCategory != "Build"))'

    }],

    //Add rules to this array that you only want in the "Drilldown App" but not on the "Pretty" dashboard.
    drilldownRules: [{
        label: 'Build Percent null',
        description: 'Counting leaf node projects where the Build Percent field is null',
        model: 'Project',
        detailFetchFields: ['Name','c_BuildPercent'],
        query: '((c_BuildPercent = "") AND (Children.State != "Open"))',
        exceptionClass: 'rule_leafprojectbuildpercentrule'
    },{
        label: 'Teams assignment is inconsistent between Owner and Story',
        description: 'Counting Active stories and child stories where the project object id is different than the value in the Workday Team on the owners person record.  Data will not include stories with Owners that do not belong to a Workday Team',
        model: 'HierarchicalRequirement',
        detailFetchFields: ['ObjectID','Name','Owner','Project'],
        query: '((((ScheduleState = "Defined") OR (ScheduleState = "In-Progress")) OR (ScheduleState = "Completed")) AND (Owner.c_WorkdayTeam != ""))',
        exceptionClass: 'rule_teamassignmentinconsistency'
    }]

});
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350,
    
    informationalConfig: null,
    
    items: [{xtype:'container', itemId:'information' }],
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/var BUILDER = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
       
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
   
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    var stored_checksum = me._generateChecksum(text);
                    if ( CHECKSUM !== stored_checksum ) {
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    _addToContainer: function(container){
        var config = Ext.apply({
            xtype:'container',
            height: 200,
            overflowY: true
        }, this.informationalConfig);
        
        container.add(config);
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if ( !Ext.isEmpty( this.informationalConfig ) ) {
            var container = this.down('#information');
            this._addToContainer(container);
            
        }
        
        if (! app.isExternal() ) {
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            dock: 'bottom',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                },
                failure: function(msg){
                    console.log("oops:",msg);
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml,
                doc: 'top'
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            dock:'bottom',
            html:"This app was created by the CA AC Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html: Ext.String.format("Build date/time: {0} ({1})",
                    APP_BUILD_DATE,
                    BUILDER)
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('CA.technicalservices.validation.RuleTemplate', {
    extend: 'Ext.XTemplate',

    /**
     * This template expects a set of rules objects in the following format:
     * {
     *   bucket: <Project Name Bucket>
     *   rules: [{
     *      label: <Short rule Label>,
     *      description: <Rule description>,
     *      flaggedCount: <Count of flagged records>,
     *      totalCount: <Count of total records>,
     *      unitLabel: <plural unit label:  e.g. stories, people>
     *   }...]
     * }
     */

    constructor: function(config) {
        var me = this;
        var columns = config.columns || 3;

        this.callParent([
            '<div class="dashboard-header">Financial Reporting Risks - {bucket}</div>',
            '<table class="dashboard-table"><tr>',
            '<tpl for="rules">',
                '<td class="dashboard-box">',
                    '<div class="{[this.getTitleClass(values)]}">{label}</div>',
                    '<div class="dashboard-percent-title">{[this.getPercentString(values)]}</div>',
                    '<div class="dashboard-subtitle">{flaggedCount} {unitLabel} out of {totalCount}</div>',
                    '<div class="dashboard-description">{description}</div>',
                '</td>',
            '<tpl if="this.isRowBreak(xindex)"></tr><tr></tpl>',
            '</tpl>',
            '</tr></table>',
            {
                columns: columns,
                getPercentString: function(values){
                    var percent = this.getPercent(values);
                    if (percent === null){
                        return 'N/A';
                    }
                    return Ext.String.format('{0}%', percent.toFixed(1));
                },
                getPercent: function(values) {
                    return values.totalCount > 0 ? (values.flaggedCount / values.totalCount * 100) : null;
                },
                isRowBreak: function(col){
                    if((col >= this.columns) && (col % this.columns === 0)){
                        return true;
                    }
                    return false;
                },
                getTitleClass: function(values){
                    var percent = this.getPercent(values);

                    if (percent === null){
                        return 'dashboard-top dashboard-gray';
                    }

                    if (percent < CA.technicalservices.dataquality.common.Rules.prettyThreshholdGreen){
                        return 'dashboard-top dashboard-green';
                    }
                    if (percent < CA.technicalservices.dataquality.common.Rules.prettyThreshholdYellow){
                        return 'dashboard-top dashboard-yellow';
                    }
                    return 'dashboard-top dashboard-red';
                }
            }
        ]);
    }
});
Ext.define('CA.technicalservices.validator.Validator',{
    alias: 'widget.tsvalidator',

    logger: new Rally.technicalservices.Logger(),
    /**
     *
     * [{rule}] An array of validation rules
     */
    rules: [],

    constructor: function(config) {
        Ext.apply(this,config);

        var rules = [];

        Ext.Array.each(this.rules, function(rule){
            var name = rule.xtype || 'tsrule_base';
            if ( !Ext.isEmpty(name) ) {
                delete rule.xtype;
                rules.push(Ext.createByAlias('widget.' + name, rule));
            }
        });
        this.logger.log('Validator.constructor', this.rules);
        this.rules = rules;
    },
    run: function(){
        var deferred = Ext.create('Deft.Deferred');
        this.logger.log('run', this.rules);
        var promises = [],
            me = this;
        Ext.Array.each(this.rules, function(rule){
            promises.push(me.updateRule(rule));
        });

        Deft.Promise.all(promises).then({
            success: function(){
                deferred.resolve(this);
            },
            failure: function(msg){
                deferred.reject(msg);
            },
            scope: this
        });

        return deferred;
    },
    updateRule: function(rule){
        var deferred = Ext.create('Deft.Deferred');

        this.logger.log('updateRule', rule.model);
        this.getTotalCount(rule.model).then({
            success: function(totalCount){
                rule.totalCount = totalCount;
                this.logger.log('updateRule.getTotalCount', rule.model, totalCount);

                var config = rule.getCountConfig();
                config.context = {
                    project: this.projectRef,
                    projectScopeDown: true
                };

                this._loadWsapiCount(config).then({
                    success: function(count){
                        this.logger.log('updateRule._loadWsapiCount', rule.getLabel(), count, config);
                        rule.flaggedCount = count;
                        deferred.resolve();
                    },
                    failure: function(msg){
                        deferred.reject(msg);
                    },
                    scope: this
                });
            },
            failure: function(msg){
                deferred.reject(msg);
            },
            scope: this
        });
        return deferred;
    },
    getTotalCount: function(model){
        var deferred = Ext.create('Deft.Deferred');
        if (this.totalCounts && this.totalCounts[model]){
            deferred.resolve(this.totalCounts[model]);
        } else {
            this._loadWsapiCount({
                model: model,
                fetch: ['ObjectID'],
                context: {
                    project: this.projectRef,
                    projectScopeDown: true
                }
            }).then({
                success: function(count){
                    if (!this.totalCounts){
                        this.totalCounts = {};
                    }
                    this.totalCounts[model] = count;
                    deferred.resolve(count);
                },
                failure: function(msg){
                    deferred.reject(msg);
                },
                scope: this
            });
        }
        return deferred;
    },
    getRules: function(){
        return this.rules;
    },
    _loadWsapiRecords: function(config) {
        var deferred = Ext.create('Deft.Deferred');

        Ext.create('Rally.data.wsapi.Store',config).load({
            callback: function(records, operation){
                if (operation.wasSuccessful()){
                    var result = {};
                    result[config.model] = records;
                    deferred.resolve(result);
                } else {
                    deferred.reject(operation.error.errors.join(','));
                }
            }
        });
        return deferred.promise;
    },
    _loadWsapiCount: function(config){
        var deferred = Ext.create('Deft.Deferred');

        config.pageSize = 1;
        config.limit = 1;

        Ext.create('Rally.data.wsapi.Store',config).load({
            callback: function(records, operation){
                if (operation.wasSuccessful()){
                    deferred.resolve(operation.resultSet.totalRecords);
                } else {
                    deferred.reject(operation.error.errors.join(','));
                }
            }
        });
        return deferred.promise;
    }
});
Ext.define("data-quality-dashboard", {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    defaults: { margin: 10 },
    items: [
        {xtype:'container',itemId:'message_box',tpl:'Hello, <tpl>{_refObjectName}</tpl>'},
        {xtype:'container',itemId:'display_box'}
    ],

    integrationHeaders : {
        name : "data-quality-dashboard"
    },

    launch: function() {
        this.createValidator()
    },
    createValidator: function(){

        var rules = Ext.Array.merge(
            CA.technicalservices.dataquality.common.Rules.rulesConfig,
            CA.technicalservices.dataquality.common.Rules.prettyRules
        );
        var validator = Ext.create('CA.technicalservices.validator.Validator',{
            bucket: this.getContext().getProject().Name,
            projectRef: this.getContext().getProject()._ref,
            rules: rules
        });

        this.setLoading(true);
        validator.run().then({
            failure: this.showErrorNotification,
            success: this.displayDashboard,
            scope: this
        }).always(function(){ this.setLoading(false); }, this);
    },
    displayDashboard: function(validator){
        this.removeAll();
        var tpl = Ext.create('CA.technicalservices.validation.RuleTemplate',{
            columns: CA.technicalservices.dataquality.common.Rules.prettyDashboardColumns
        });

        this.add({
            xtype: 'container',
            tpl: tpl,
            margin: '0 100 0 100',
            flex: 1
        }).update(validator);
    },
    showErrorNotification: function(msg){
        this.logger.log('showErrorNotification', msg);
        Rally.ui.notify.Notifier.showError({
            message: msg
        });
    },
    getOptions: function() {
        return [
            {
                text: 'About...',
                handler: this._launchInfo,
                scope: this
            }
        ];
    },
    _launchInfo: function() {
        if ( this.about_dialog ) { this.about_dialog.destroy(); }
        this.about_dialog = Ext.create('Rally.technicalservices.InfoLink',{});
    },
    
    isExternal: function(){
        return typeof(this.getAppId()) == 'undefined';
    },
    //onSettingsUpdate:  Override
    onSettingsUpdate: function (settings){
        this.logger.log('onSettingsUpdate',settings);
        // Ext.apply(this, settings);
        this.launch();
    }
});

            
               Rally.launchApp('data-quality-dashboard', {
                   name: 'Data Quality Dashboard'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}
.dashboard-title {
    width: 100%;
    font-family: ProximaNovaSemiBold, Helvetica, Arial;
    font-size: 14px;
    padding: 5px;
    text-align: center;
}
.dashboard-percent-title {
    font-family: ProximaNovaSemiBold, Helvetica, Arial;
    font-size: 16px;
    text-align: center;
    vertical-align: middle;
    padding: 15px 10px 10px 10px;
}
.dashboard-subtitle{
    font-family: ProximaNovaSemiBold, Helvetica, Arial;
    font-size: 11px;
    text-align: center;
    padding: 10px;
}
.dashboard-header{
    color: #222222;
    font-family: ProximaNovaSemiBold, Helvetica, Arial;
    font-size: 14px;
    padding: 10px;
    text-align: left;
}
.dashboard-description {
    text-align: left;
    padding: 15px;
    color: #888888;
    font-family: ProximaNova, Helvetica, Arial;
    font-size: 11px;
}
.dashboard-box{
    border-width: 1px;
    border-color: #000;
    border-style: solid;
    vertical-align: top;
    padding: 0px;
    width: 100%;
}

.dashboard-gray {
    background-color: #f6f6f6;
    color: #888;
}

.dashboard-top {
    height: 75px;
    width: 100%;
    font-family: ProximaNovaSemiBold, Helvetica, Arial;
    font-size: 16px;
    text-align: center;
    padding: 15px 10px 10px 10px;
    vertical-align: middle;
}
.dashboard-red {
    background-color: #F2D3D0;
    color: #B81B10;
}
.dashboard-green {
    background-color: #e3f9e9;
    color: #1E7C00;
}
.dashboard-yellow {
    background-color: #FFEDBF;
    color: #FF8200;
}
.dashboard-table {
    border-collapse: collapse;
    border-color: grey;
    width: 100%;
    table-layout: fixed;
}
    </style>

</head>
<body></body>
</html>