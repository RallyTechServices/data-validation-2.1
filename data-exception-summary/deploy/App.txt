<!DOCTYPE html>
<html>
<head>
    <title>Data Exception Summary</title>
    <!--  (c) 2016 CA Technologies.  All Rights Reserved. -->
    <!--  Build Date: Wed Nov 09 2016 13:48:20 GMT-0700 (MST) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Wed Nov 09 2016 13:48:20 GMT-0700 (MST)";
        var BUILDER = "kcorkan";
        var CHECKSUM = 191081253977;
    </script>
    
    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
Ext.define('CA.techservices.validation.BaseRule',{
    extend: 'Ext.Base',
    /*
     * [{Rally.wsapi.data.Model}] portfolioItemTypes the list of PIs available
     * we're going to use the first level ones (different workspaces name their portfolio item levels differently)
     */
    portfolioItemTypes:[],
    /**
     *
     * @cfg
     * {String} model The name of a record type that this rule applies to
     */
    model: null,
    /**
     *
     * @cfg {String} a human-readable label for the chart that will be made from the rule
     */
    label: 'No label supplied for this rule',

    constructor: function(config) {
        Ext.apply(this,config);
    },

    shouldExecuteRule: true,
    getFeatureName: function(){
        return this.portfolioItemTypes && this.portfolioItemTypes.length > 1 &&
            this.portfolioItemTypes[0].TypePath.replace('PortfolioItem/','');
    },
    getDescription: function() {
        return this.description;
    },

    getFetchFields: function() {
        return [];
    },
    getLabel: function() {
        //console.error('getLabel is not implemented in subclass ', this.self.getName());
        return this.label;
    },
    getModel: function() {
        return this.model;
    },

    getFilters: function() {
        return Ext.create('Rally.data.wsapi.Filter', {
            property:'ObjectID',
            operator:'>',
            value: 0
        });
    },
    // return false if the record doesn't match
    // return string if record fails the rule
    applyRuleToRecord: function(record) {
        console.error('applyRuleToRecord not implemented in subclass ', this.self.getName());
        throw 'applyRuleToRecord not implemented in subclass ' + this.self.getName();

        return record;
    },

    fetchUpdate: function(projectID){

    },
    /* override to allow the validator to check if the rule makes sense to run 
     * (e.g., the field checker for fields that don't even exist)
     * 
     * resolve promise with text if problem -- the validator will return the text so
     * it can be put into a description
     * 
     * The rule will still be executed unless this.shouldExecuteRule is set to false (and
     * the rule class implements skipping because of this.shouldExecuteRule).
     * 
     * A rule class could be multi-part and only partially fail, so execution or not execution
     * needs to be handled by the class itself.
     * 
     */
    precheckRule: function() {
        return null;
    },

    getUserFriendlyRuleLabel: function() {
        return this.getLabel();
    },
    getDetailFetchFields: function(){
        return this.getFetchFields();
    }
});
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350,
    
    informationalConfig: null,
    
    items: [{xtype:'container', itemId:'information' }],
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/var BUILDER = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
       
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
   
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    var stored_checksum = me._generateChecksum(text);
                    if ( CHECKSUM !== stored_checksum ) {
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    _addToContainer: function(container){
        var config = Ext.apply({
            xtype:'container',
            height: 200,
            overflowY: true
        }, this.informationalConfig);
        
        container.add(config);
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if ( !Ext.isEmpty( this.informationalConfig ) ) {
            var container = this.down('#information');
            this._addToContainer(container);
            
        }
        
        if (! app.isExternal() ) {
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            dock: 'bottom',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                },
                failure: function(msg){
                    console.log("oops:",msg);
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml,
                doc: 'top'
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            dock:'bottom',
            html:"This app was created by the CA AC Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html: Ext.String.format("Build date/time: {0} ({1})",
                    APP_BUILD_DATE,
                    BUILDER)
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('CA.techservices.validation.ActiveStoryEmptyTeam',{
    extend: 'CA.techservices.validation.BaseRule',
    alias:  'widget.tsrule_activestoryemptyteam',

    /**
     *
     *  LeafNodeStories
     *
     *  Rule Criteria:
     *
     *  Build Percent for team is >0or Null.
     *  Parent Initiative has an Investment Category of "Build"
     *  Parent Initiative state is "In-Progress" or "Staging"
     *  Story state is in "Defined", "In-Progress" or "Complete"
     *  Story is in a Project Leaf Node
     *
     *
     */
    config: {
        /*
         * [{Rally.wsapi.data.Model}] portfolioItemTypes the list of PIs available
         * we're going to use the first level ones (different workspaces name their portfolio item levels differently)
         */
        model: 'HierarchicalRequirement',

        portfolioItemTypes: null,

        label: 'User Stories in a team with no members',
        description: 'Build Percent for team is >0or Null. ' +
        'Parent Initiative has an Investment Category of "Build" ' +
        'Parent Initiative state is "In-Progress" or "Staging" ' +
        'Story state is in "Defined", "In-Progress" or "Complete" ' +
        'Story is in a team that is not a leaf node',
        buildPercentField: 'c_BuildPercent',
        initiativeStates: ["In-Progress","Staging"],
        initiativeInvestmentCategories: ["Build"],
        stateField: "ScheduleState",
        stateIsIn: ["Defined","In-Progress","Completed"],
    },
    getFetchFields: function() {
        return ['FormattedID','Name',this.getFeatureName(),'ScheduleState','Project'];
        return ['FormattedID','Name',this.getFeatureName(),'Parent','InvestmentCategory','State','ScheduleState','Project', this.buildPercentField, 'PlanEstimate'];
    },
    getFeatureName: function(){
        return this.portfolioItemTypes[0].TypePath.replace('PortfolioItem/','');
    },
    applyRuleToRecord: function(record) {
        var recData = record.getData(),
            initiative = recData[this.getFeatureName()] && recData[this.getFeatureName()].Parent,
            project = recData.Project.ObjectID;

        if (initiative &&
            (Ext.Array.contains(this.stateIsIn), recData.ScheduleState) &&
            (recData.Project[this.buildPercentField] !== 0) &&
            (Ext.Array.contains(this.initiativeInvestmentCategories, initiative.InvestmentCategory)) &&
            (initiative.State && initiative.State.Name &&
            Ext.Array.contains(this.initiativeStates, initiative.State.Name)) &&
            !this.projectUtility.isProjectLeafNode(project)){

            return this.getDescription();
        }
        return null; // no rule violation
    },
    getFilters: function(){
        /**
         *  Rule Criteria:
         *
         *  Build Percent for team is >0or Null.
         *  Parent Initiative has an Investment Category of "Build"
         *  Parent Initiative state is "In-Progress" or "Staging"
         *  Story state is in "Defined", "In-Progress" or "Complete"
         *  Story Size is null
         *
         */

        //Parent Initiative state is "In-Progress" or "Staging"
        var intiativeStateCriteria = [{
            property: this.getFeatureName() + ".Parent.State.Name",
            value: "In-Progress"
        },{
            property: this.getFeatureName() + ".Parent.State.Name",
            value: "Staging"
        }];
        intiativeStateCriteria = Rally.data.wsapi.Filter.or(intiativeStateCriteria);

        //Story state is in "Defined", "In-Progress" or "Complete"
        var storyStateCriteria = [{
            property: 'ScheduleState',
            value: 'Defined'
        },{
            property: 'ScheduleState',
            value: 'In-Progress'
        },{
            property: 'ScheduleState',
            value: 'Completed'
        }];
        storyStateCriteria = Rally.data.wsapi.Filter.or(storyStateCriteria);

        var filters = intiativeStateCriteria.and(storyStateCriteria);

        // Build Percent for team is >0or Null.
        // Parent Initiative has an Investment Category of "Build"
        // Project has no team members

        var otherFilters = Rally.data.wsapi.Filter.and([{
            property: this.getFeatureName() + '.Parent.InvestmentCategory',
            value: "Build"
        },{
            property: 'Project.TeamMembers.ObjectID',
            value: "null"
        }]);

        return filters.and(otherFilters);
    }
});
Ext.define('CA.techservices.validation.PortfolioNotSized',{
    extend: 'CA.techservices.validation.BaseRule',
    alias:  'widget.tsrule_portfolionotsized',

    /**
     *
     * Parent Initiative has an Investment Category of "Build"
     * Feature state is "In-Progress" or "Staging"
     * Feature field is not sized
     */

    config: {
        /*
         * [{Rally.wsapi.data.Model}] portfolioItemTypes the list of PIs available
         * we're going to use the first level ones (different workspaces name their portfolio item levels differently)
         */
        portfolioItemTypes:[],
        targetPortfolioLevel: 0,

        label: '{0}s are not sized',
        description:  '{0}s are not sized.  <br/>Parent {1} has an Investment Category of "Build"<br/>' +
                      '{0} state is "In-Progress" or "Staging"<br/>' +
                      '{0} field is not sized',
        featureSizeField: 'PreliminaryEstimate',
        stateValues: ['In-Progress','Staging']
    },
    getModel:function(){
        return this.portfolioItemTypes[this.targetPortfolioLevel].TypePath;
    },
    getDescription: function() {
        var msg = Ext.String.format(
            this.description,
            this.portfolioItemTypes[this.targetPortfolioLevel].Name,
            this.portfolioItemTypes[this.targetPortfolioLevel+1].Name
        );
        return msg;
    },
    getFetchFields: function() {
        return ['FormattedID','Name','Parent','InvestmentCategory','State',this.featureSizeField];
    },
    getLabel: function(){
        var msg = Ext.String.format(
            this.label,
            this.portfolioItemTypes[this.targetPortfolioLevel].Name
        );
        return msg;
    },
    getFilters: function(){

        /**
         *
         * Parent Initiative has an Investment Category of "Build"
         * Feature state is "In-Progress" or "Staging"
         * Feature field is not sized
         */
        var filters = Ext.Array.map(this.stateValues, function(s){
            return {
                property: 'State',
                value: s
            }
        });
        filters = Rally.data.wsapi.Filter.or(filters);

        filters = filters.and(Ext.create('Rally.data.wsapi.Filter', {
            property: "InvestmentCategory",
            value: "Build"
        }));

        filters = filters.and(Ext.create('Rally.data.wsapi.Filter', {
            property: "PreliminaryEstimate",
            value: ""
        }));

        return filters;
    }
});
Ext.define('CA.techservices.validation.InvestmentCategoryMisaligned',{
    extend: 'CA.techservices.validation.BaseRule',
    alias:  'widget.tsrule_investmentcategorymisaligned',

    /**
     *
     * Parent has an Investment Category of "Build"
     * Initiative state is "Elaborating", "In-Progress" or "Staging"
     * Feature Investment Category does not match Initiative
     */

    config: {
        /*
         * [{Rally.wsapi.data.Model}] portfolioItemTypes the list of PIs available
         * we're going to use the first level ones (different workspaces name their portfolio item levels differently)
         */
        portfolioItemTypes:[],
        targetPortfolioLevel: 0,

        label: 'Investment Category between {0} and {1} are not aligned',
        description:  'Investment Category between {0} and {1} are not aligned.  <br/>Parent {1} has an Investment Category of "Build"<br/>' +
        '{1} state is {2}<br/>' +
        '{0} Investment Category does not match {1} Parent',
        stateValues: ['Elaborate','In-Progress','Staging']
    },
    getModel:function(){
        return this.portfolioItemTypes[this.targetPortfolioLevel].TypePath;
    },
    getDescription: function() {
        var msg = Ext.String.format(
            this.description,
            this.portfolioItemTypes[0].Name,
            this.portfolioItemTypes[1].Name,
            this.stateValues.join(', ')
        );
        return msg;
    },
    getFetchFields: function() {
        return ['FormattedID','Name','Parent','InvestmentCategory','State'];
    },
    getLabel: function(){
        var msg = Ext.String.format(
            this.label,
            this.portfolioItemTypes[0].Name,
            this.portfolioItemTypes[1].Name
        );
        return msg;
    },
    applyRuleToRecord: function(record) {
        if ( !record.get('Parent') && record.get(this.criteriaField) === this.criteriaValue ) {
            return this.getDescription();
        } else {
            return null; // no rule violation
        }
    },
    getFilters: function(){

        /**
         * Parent has an Investment Category of "Build"
         * Initiative state is "Elaborating", "In-Progress" or "Staging"
         * Feature Investment Category does not match Initiative
         */
        var filters = Ext.Array.map(this.stateValues, function(s){
            return {
                property: 'Parent.State.Name',
                value: s
            }
        });
        filters = Rally.data.wsapi.Filter.or(filters);

        filters = filters.and(Ext.create('Rally.data.wsapi.Filter', {
            property: "Parent.InvestmentCategory",
            value: "Build"
        }));

        filters = filters.and(Ext.create('Rally.data.wsapi.Filter', {
            property: "InvestmentCategory",
            operator: '!=',
            value: "Build"
        }));

        return filters;
    }
});
Ext.define('CA.techservices.validation.LeafNodeStories',{
    extend: 'CA.techservices.validation.BaseRule',
    alias:  'widget.tsrule_leafnodestories',

    /**
     *
     *  LeafNodeStories
     *
     *  Rule Criteria:
     *
     *  Build Percent for team is >0or Null.
     *  Parent Initiative has an Investment Category of "Build"
     *  Parent Initiative state is "In-Progress" or "Staging"
     *  Story state is in "Defined", "In-Progress" or "Complete"
     *  Story is in a Project Leaf Node
     *
     *
     */
    config: {
        /*
         * [{Rally.wsapi.data.Model}] portfolioItemTypes the list of PIs available
         * we're going to use the first level ones (different workspaces name their portfolio item levels differently)
         */
        model: 'HierarchicalRequirement',

        portfolioItemTypes: null,

        label: 'User Stories not in a delivery (Leaf Node) team',
        description: 'Build Percent for team is >0or Null. ' +
        'Parent Initiative has an Investment Category of "Build" ' +
        'Parent Initiative state is "In-Progress" or "Staging" ' +
        'Story state is in "Defined", "In-Progress" or "Complete" ' +
        'Story is in a team that is not a leaf node',
        buildPercentField: 'c_BuildPercent',
        initiativeStates: ["In-Progress","Staging"],
        initiativeInvestmentCategories: ["Build"],
        stateField: "ScheduleState",
        stateIsIn: ["Defined","In-Progress","Completed"],
    },
    getFetchFields: function() {
        return ['FormattedID','Name',this.getFeatureName(),'InvestmentCategory','ScheduleState','Project', 'PlanEstimate'];
        return ['FormattedID','Name',this.getFeatureName(),'Parent','InvestmentCategory','State','ScheduleState','Project', this.buildPercentField, 'PlanEstimate'];
    },
    getDetailFetchFields: function(){
        return ['FormattedID','Name',this.getFeatureName(),'InvestmentCategory','ScheduleState','Project', 'PlanEstimate'];
    },
    getFeatureName: function(){
        return this.portfolioItemTypes[0].TypePath.replace('PortfolioItem/','');
    },
    applyRuleToRecord: function(record) {
        var recData = record.getData(),
            initiative = recData[this.getFeatureName()] && recData[this.getFeatureName()].Parent,
            project = recData.Project.ObjectID;

        if (initiative &&
            (Ext.Array.contains(this.stateIsIn), recData.ScheduleState) &&
            (recData.Project[this.buildPercentField] !== 0) &&
            (Ext.Array.contains(this.initiativeInvestmentCategories, initiative.InvestmentCategory)) &&
            (initiative.State && initiative.State.Name &&
            Ext.Array.contains(this.initiativeStates, initiative.State.Name)) &&
            !this.projectUtility.isProjectLeafNode(project)){

            return this.getDescription();
        }
        return null; // no rule violation
    },
    getFilters: function(){
        /**
         *  Rule Criteria:
         *
         *  Build Percent for team is >0or Null.
         *  Parent Initiative has an Investment Category of "Build"
         *  Parent Initiative state is "In-Progress" or "Staging"
         *  Story state is in "Defined", "In-Progress" or "Complete"
         *  Story Size is null
         *
         */

        //Parent Initiative state is "In-Progress" or "Staging"
        var intiativeStateCriteria = [{
            property: this.getFeatureName() + ".Parent.State.Name",
            value: "In-Progress"
        },{
            property: this.getFeatureName() + ".Parent.State.Name",
            value: "Staging"
        }];
        intiativeStateCriteria = Rally.data.wsapi.Filter.or(intiativeStateCriteria);

        //Story state is in "Defined", "In-Progress" or "Complete"
        var storyStateCriteria = [{
            property: 'ScheduleState',
            value: 'Defined'
        },{
            property: 'ScheduleState',
            value: 'In-Progress'
        },{
            property: 'ScheduleState',
            value: 'Completed'
        }];
        storyStateCriteria = Rally.data.wsapi.Filter.or(storyStateCriteria);

        var filters = intiativeStateCriteria.and(storyStateCriteria);

        // Build Percent for team is >0or Null.
        // Parent Initiative has an Investment Category of "Build"
        // Project is not in a leaf node project

        var otherFilters = Rally.data.wsapi.Filter.and([{
            property: this.getFeatureName() + '.Parent.InvestmentCategory',
            value: "Build"
        },{
            property: 'Project.Children.State',
            value: "Open"
        },{
            property: 'Project.' + this.buildPercentField,
            operator: '!=',
            value: 0
        }]);

        return filters.and(otherFilters);
    }
});
Ext.define('CA.techservices.validation.PortfolioOrphan',{
    extend: 'CA.techservices.validation.BaseRule',
    alias:  'widget.tsrule_portfolioorphan',


    config: {
        /*
         * [{Rally.wsapi.data.Model}] portfolioItemTypes the list of PIs available
         * we're going to use the first level ones (different workspaces name their portfolio item levels differently)
         */
        portfolioItemTypes:[],
        targetPortfolioLevel: 0,

        label: 'Orphaned {0}',
        description: '{0} has an {1} of "{2}" and {0} has no parent',
        criteriaField: 'InvestmentCategory',
        criteriaValue: 'Build',
    },
    getModel:function(){
        return this.portfolioItemTypes[this.targetPortfolioLevel].TypePath;
    },
    getDescription: function() {
        var msg = Ext.String.format(
            this.description,
            this.portfolioItemTypes[this.targetPortfolioLevel].Name,
            this.criteriaField,
            this.criteriaValue
        );
        return msg;
    },
    getFetchFields: function() {
        return ['FormattedID','Name','Parent',this.criteriaField];
    },
    getLabel: function(){
        var msg = Ext.String.format(
            this.label,
            this.portfolioItemTypes[this.targetPortfolioLevel].Name
        );
        return msg;
    },
    applyRuleToRecord: function(record) {
        if ( !record.get('Parent') && record.get(this.criteriaField) === this.criteriaValue ) {
            return this.getDescription();
        } else {
            return null; // no rule violation
        }
    },
    getFilters: function(){
        return Rally.data.wsapi.Filter.and([{
            property: 'Parent',
            value: null
        },{
            property: this.criteriaField,
            value: this.criteriaValue
        }]);
    }
});
Ext.define('CA.techservices.validation.UserStoryOrphan',{
    extend: 'CA.techservices.validation.BaseRule',
    alias:  'widget.tsrule_userstoryorphan',

/**
 *
 *  UserStoryOrphan
 *
 *  Rule Criteria:
 *
 *  Story Type is "Standard" or Null
 *  Build Percent for team is > 0 or Null
 *  Story state has left "Unelaborated"
 *  Story has no parent
 *
 */
    config: {
        /*
         * [{Rally.wsapi.data.Model}] portfolioItemTypes the list of PIs available
         * we're going to use the first level ones (different workspaces name their portfolio item levels differently)
         */
        model: 'HierarchicalRequirement',

        label: 'Orphaned User Stories',
        description: 'Story Type is "Standard" or null, Build Percent for team > 0, Story State > "Unelaborated" and Story has no Parent',

        buildPercentField: 'c_BuildPercent',
        storyTypeField: 'c_StoryType',
        storyTypeValues: ["Standard"],
        stateField: "ScheduleState",
        notInState: "Unelaborated",
    },
    getFetchFields: function() {
        return ['FormattedID','Name',this.getFeatureName(),'ScheduleState','Project', this.storyTypeField];
        return ['FormattedID','Name','Parent','PortfolioItem','ScheduleState','Project',this.buildPercentField, this.storyTypeField];
    },
    applyRuleToRecord: function(record) {
        if (!record.get(this.storyTypeField) || Ext.Array.contains(this.storyTypeValues, record.get(this.storyTypeField))){
            var state = record.get(this.stateField),
                parent = record.get("Parent") || record.get('PortfolioItem') || null,
                buildPercent = record.get('Project') && record.get('Project')[this.buildPercentField] || 0;

            if (buildPercent > 0 && state !== this.notInState && !parent){
                return this.getDescription();
            }
        }
        return null; // no rule violation
    },
    getFilters: function(){

        /**
         *  Rule Criteria:
         *
         *  Story Type is "Standard" or Null
         *  Build Percent for team is > 0 or Null
         *  Story state has left "Unelaborated"
         *  Story has no parent
         *
         */

        var storyTypeFilters = Ext.Array.map(this.storyTypeValues, function(v){
            return {
                property: this.storyTypeField,
                value: v
            };
        }, this);

        storyTypeFilters.push({
            property: this.storyTypeField,
            value: ""
        });

        var filters = Rally.data.wsapi.Filter.or(storyTypeFilters);

        var otherFilters = Rally.data.wsapi.Filter.and([{
            property: this.getFeatureName(),
            value: null
        },{
            property: 'ScheduleState',
            operator: '>',
            value: this.notInState
        },{
            property: 'Project.' + this.buildPercentField,
            operator: '!=',
            value: 0
        }]);

        return filters.and(otherFilters);
    }
});
Ext.define('CA.techservices.validation.ActiveStoriesInactiveInitiative',{
    extend: 'CA.techservices.validation.BaseRule',
    alias:  'widget.tsrule_activestoriesinactiveinitiative',

    /**
     * Build Percent for team is >0or Null.
     * Parent Initiative has an Investment Category of "Build"
     * Parent Initiative state is NOT "In-Progress" or "Staging"
     * Stories state is "Defined", "In-Progress", or "Complete"
     * Story type is "Standard" or Null
     **/

    config: {
        /*
         * [{Rally.wsapi.data.Model}] portfolioItemTypes the list of PIs available
         * we're going to use the first level ones (different workspaces name their portfolio item levels differently)
         */
        portfolioItemTypes:[],
        model: 'HierarchicalRequirement',

        label: 'Active Stories on Inactive {0}',
        description: 'Active Stories on Inactive {0}:<br/>Build Percent for team is >0 or Null.<br/>' +
                     'Parent {0} has an Investment Category of "Build"<br/>' +
                     'Parent {0} state is NOT "In-Progress" or "Staging"<br/>' +
                     'Story state is "Defined", "In-Progress", or "Complete"<br/>' +
                     'Story type is "Standard" or Null<br/>',
        storyTypeField: 'c_StoryType',
        buildPercentField: 'c_BuildPercent'
    },

    getDescription: function() {
        var msg = Ext.String.format(
            this.description,
            this.portfolioItemTypes[1].Name
        );
        return msg;
    },
    getFetchFields: function() {
        return ['ObjectID','Name',this.getFeatureName(),'Parent','InvestmentCategory','State','ScheduleState','Project', this.buildPercentField, 'PlanEstimate'];
    },
    getDetailFetchFields: function() {
        return ['FormattedID','Name',this.getFeatureName(),'ScheduleState','Project'];
    },
    getLabel: function(){
        var msg = Ext.String.format(
            this.label,
            this.portfolioItemTypes[1].Name
        );
        return msg;
    },
    applyRuleToRecord: function(record) {
        if ( !record.get('Parent') && record.get(this.criteriaField) === this.criteriaValue ) {
            return this.getDescription();
        } else {
            return null; // no rule violation
        }
    },
    getFilters: function(){
        /**
         *  Rule Criteria:
         *
         * Build Percent for team is >0or Null.
         * Parent Initiative has an Investment Category of "Build"
         * Parent Initiative state is NOT "In-Progress" or "Staging"
         * Stories state is "Defined", "In-Progress", or "Complete"
         * Story type is "Standard" or Null
         *
         */

        //Parent Initiative state is NOT "In-Progress" or "Staging"
        var intiativeStateCriteria = [{
            property: this.getFeatureName() + ".Parent.State.Name",
            operator: '!=',
            value: "In-Progress"
        },{
            property: this.getFeatureName() + ".Parent.State.Name",
            operator: '!=',
            value: "Staging"
        }];
        intiativeStateCriteria = Rally.data.wsapi.Filter.and(intiativeStateCriteria);

        //Story state is in "Defined", "In-Progress" or "Complete"
        var storyStateCriteria = [{
            property: 'ScheduleState',
            value: 'Defined'
        },{
            property: 'ScheduleState',
            value: 'In-Progress'
        },{
            property: 'ScheduleState',
            value: 'Completed'
        }];

        storyStateCriteria = Rally.data.wsapi.Filter.or(storyStateCriteria);
        var filters = intiativeStateCriteria.and(storyStateCriteria);
        console.log('filters+initativeStatecriteria', filters.toString());

        var storyTypeCriteria = [{
            property: this.storyTypeField,
            value: "Standard"
        },{
            property: this.storyTypeField,
            value: ""
        }];
        storyTypeCriteria = Rally.data.wsapi.Filter.or(storyTypeCriteria);
        console.log('storyTypeCriteria', storyTypeCriteria.toString());

        filters = filters.and(storyTypeCriteria);
        console.log('filters1', filters.toString());

        // Build Percent for team is >0or Null.
        // Parent Initiative has an Investment Category of "Build"
        // Story Size is null
        var otherFilters = Rally.data.wsapi.Filter.and([{
            property: this.getFeatureName() + '.Parent.InvestmentCategory',
            value: "Build"
        },{
            property: 'Project.' + this.buildPercentField,
            operator: '!=',
            value: 0
        }]);
        console.log('filters', filters.toString());
        return filters.and(otherFilters);
    }
});
Ext.define('CA.techservices.validation.UnsizedStories',{
    extend: 'CA.techservices.validation.BaseRule',
    alias:  'widget.tsrule_unsizedstories',

    /**
     *
     *  UnsizedStories
     *
     *  Rule Criteria:
     *
     *  Build Percent for team is >0or Null.
     *  Parent Initiative has an Investment Category of "Build"
     *  Parent Initiative state is "In-Progress" or "Staging"
     *  Story state is in "Defined", "In-Progress" or "Complete"
     *  Story Size is null
     *
     */


    query: '(((Project.c_BuildPercent != 0) AND (Parent.InvestmentCategory = "Build")) AND ((((ScheduleState = "Defined") OR (ScheduleState = "In-Progress")) OR)',
    config: {
        /*
         * [{Rally.wsapi.data.Model}] portfolioItemTypes the list of PIs available
         * we're going to use the first level ones (different workspaces name their portfolio item levels differently)
         */
        model: 'HierarchicalRequirement',

        portfolioItemTypes: null,

        label: 'Unsized User Stories',
        description: 'Build Percent for team is >0or Null. ' +
                'Parent Initiative has an Investment Category of "Build" ' +
                'Parent Initiative state is "In-Progress" or "Staging" ' +
                'Story state is in "Defined", "In-Progress" or "Complete" ' +
                'Story Size is null ',
        buildPercentField: 'c_BuildPercent',
        initiativeStates: ["In-Progress","Staging"],
        initiativeInvestmentCategories: ["Build"],
        stateField: "ScheduleState",
        stateIsIn: ["Defined","In-Progress","Completed"],
    },
    getFetchFields: function() {
        return ['ObjectID','Name',this.getFeatureName(),'Parent','InvestmentCategory','State','ScheduleState','Project', this.buildPercentField, 'PlanEstimate'];
    },
    getDetailFetchFields: function() {
        return ['FormattedID','Name', 'PlanEstimate',this.getFeatureName(),'ScheduleState','Project'];
    },
    applyRuleToRecord: function(record) {
        var recData = record.getData(),
            initiative = recData[this.getFeatureName()] && recData[this.getFeatureName()].Parent;

        if (initiative &&
            (!recData.PlanEstimate && recData.PlanEstimate !== 0) &&
            (Ext.Array.contains(this.stateIsIn), recData.ScheduleState) &&
            (recData.Project[this.buildPercentField] !== 0) &&
            (Ext.Array.contains(this.initiativeInvestmentCategories, initiative.InvestmentCategory)) &&
            (initiative.State && initiative.State.Name &&
                Ext.Array.contains(this.initiativeStates, initiative.State.Name))){

            return this.getDescription();
        }
        return null; // no rule violation
    },
    getFilters: function(){
        /**
         *  Rule Criteria:
         *
         *  Build Percent for team is >0or Null.
         *  Parent Initiative has an Investment Category of "Build"
         *  Parent Initiative state is "In-Progress" or "Staging"
         *  Story state is in "Defined", "In-Progress" or "Complete"
         *  Story Size is null
         *
         */

        //Parent Initiative state is "In-Progress" or "Staging"
        var intiativeStateCriteria = [{
            property: this.getFeatureName() + ".Parent.State.Name",
            value: "In-Progress"
        },{
            property: this.getFeatureName() + ".Parent.State.Name",
            value: "Staging"
        }];
        intiativeStateCriteria = Rally.data.wsapi.Filter.or(intiativeStateCriteria);

        //Story state is in "Defined", "In-Progress" or "Complete"
        var storyStateCriteria = [{
            property: 'ScheduleState',
            value: 'Defined'
        },{
            property: 'ScheduleState',
            value: 'In-Progress'
        },{
            property: 'ScheduleState',
            value: 'Completed'
        }];
        storyStateCriteria = Rally.data.wsapi.Filter.or(storyStateCriteria);

        var filters = intiativeStateCriteria.and(storyStateCriteria);

        // Build Percent for team is >0or Null.
        // Parent Initiative has an Investment Category of "Build"
        // Story Size is null
        var otherFilters = Rally.data.wsapi.Filter.and([{
            property: this.getFeatureName() + '.Parent.InvestmentCategory',
            value: "Build"
        },{
            property: 'PlanEstimate',
            value: ""
        },{
            property: 'Project.' + this.buildPercentField,
            operator: '!=',
            value: 0
        }]);

        return filters.and(otherFilters);
    }
});
/**
 * Created by kcorkan on 11/4/16.
 */
Ext.define('recordHolder',{
    data: {},
    constructor: function(config) {
        Ext.apply(this, config);
    },

    get: function(field) {
        return this.data[field];
    }
});

Ext.define('Rally.technicalservices.FileUtilities', {
    singleton: true,
    logger: new Rally.technicalservices.Logger(),

    saveCSVToFile:function(csv,file_name,type_object){
        if (type_object === undefined){
            type_object = {type:'text/csv;charset=utf-8'};
        }
        this.saveAs(csv,file_name, type_object);
    },

    saveAs: function(textToWrite, fileName)
    {
        this.logger.log('saveAs:', fileName);

        if (Ext.isIE9m){
            Rally.ui.notify.Notifier.showWarning({message: "Export is not supported for IE9 and below."});
            return;
        }

        var textFileAsBlob = null;
        try {
            textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});
        }
        catch(e){
            this.logger.log('Caught an error ', e);

            window.BlobBuilder = window.BlobBuilder ||
                window.WebKitBlobBuilder ||
                window.MozBlobBuilder ||
                window.MSBlobBuilder;
            if (window.BlobBuilder ) { //&&  e.name === 'TypeError'){
                bb = new BlobBuilder();
                bb.append([textToWrite]);
                textFileAsBlob = bb.getBlob("text/plain");
            }

        }

        if (!textFileAsBlob){
            Rally.ui.notify.Notifier.showWarning({message: "Export is not supported for this browser."});
            return;
        }

        var fileNameToSaveAs = fileName;

        if (Ext.isIE10p){
            window.navigator.msSaveOrOpenBlob(textFileAsBlob,fileNameToSaveAs); // Now the user will have the option of clicking the Save button and the Open button.
            return;
        }

        var url = this.createObjectURL(textFileAsBlob);

        if (url){
            var downloadLink = document.createElement("a");
            if ("download" in downloadLink){
                downloadLink.download = fileNameToSaveAs;
            } else {
                //Open the file in a new tab
                downloadLink.target = "_blank";
            }

            downloadLink.innerHTML = "Download File";
            downloadLink.href = url;
            if (!Ext.isChrome){
                // Firefox requires the link to be added to the DOM
                // before it can be clicked.
                downloadLink.onclick = this.destroyClickedElement;
                downloadLink.style.display = "none";
                document.body.appendChild(downloadLink);
            }
            downloadLink.click();
        } else {
            Rally.ui.notify.Notifier.showError({message: "Export is not supported "});
        }

    },
    createObjectURL: function ( file ) {
        if ( window.webkitURL ) {
            return window.webkitURL.createObjectURL( file );
        } else if ( window.URL && window.URL.createObjectURL ) {
            return window.URL.createObjectURL( file );
        } else {
            return null;
        }
    },
    saveTextAsFile: function(textToWrite, fileName) {
        var textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});
        var fileNameToSaveAs = fileName;

        var downloadLink = document.createElement("a");
        downloadLink.download = fileNameToSaveAs;
        downloadLink.innerHTML = "Download File";
        if (window.webkitURL != null)
        {
            // Chrome allows the link to be clicked
            // without actually adding it to the DOM.
            downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
        }
        else
        {
            // Firefox requires the link to be added to the DOM
            // before it can be clicked.
            downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
            downloadLink.onclick = destroyClickedElement;
            downloadLink.style.display = "none";
            document.body.appendChild(downloadLink);
        }
        downloadLink.click();
    },
    destroyClickedElement: function(event)
    {
        document.body.removeChild(event.target);
    },
    convertDataArrayToCSVText: function(data_array, requestedFieldHash){

        var text = '';
        Ext.each(Object.keys(requestedFieldHash), function(key){
            text += requestedFieldHash[key] + ',';
        });
        text = text.replace(/,$/,'\n');

        Ext.each(data_array, function(d){
            Ext.each(Object.keys(requestedFieldHash), function(key){
                if (d[key]){
                    if (typeof d[key] === 'object'){
                        if (d[key].FormattedID) {
                            text += Ext.String.format("\"{0}\",",d[key].FormattedID );
                        } else if (d[key].Name) {
                            text += Ext.String.format("\"{0}\",",d[key].Name );
                        } else if (!isNaN(Date.parse(d[key]))){
                            text += Ext.String.format("\"{0}\",",Rally.util.DateTime.formatWithDefaultDateTime(d[key]));
                        }else {
                            text += Ext.String.format("\"{0}\",",d[key].toString());
                        }
                    } else {
                        text += Ext.String.format("\"{0}\",",d[key] );
                    }
                } else {
                    text += ',';
                }
            },this);
            text = text.replace(/,$/,'\n');
        },this);
        return text;
    },
    _getCSVFromWsapiBackedGrid: function(grid,skip_headers) {
        var deferred = Ext.create('Deft.Deferred');
        var store = Ext.create('Rally.data.wsapi.Store',{
            fetch: grid.getStore().config.fetch,
            filters: grid.getStore().config.filters,
            model: grid.getStore().config.model,
            pageSize: 200
        });

        var columns = grid.columns;

        var record_count = grid.getStore().getTotalCount(),
            page_size = grid.getStore().pageSize,
            pages = Math.ceil(record_count/page_size),
            promises = [];

        for (var page = 1; page <= pages; page ++ ) {
            promises.push(this.loadStorePage(grid, store, columns, page, pages));
        }
        Deft.Promise.all(promises).then({
            success: function(csvs){
                var csv = [];
                if ( !skip_headers ) {
                    csv.push('"' + this._getHeadersFromGrid(grid).join('","') + '"');
                }
                _.each(csvs, function(c){
                    _.each(c, function(line){
                        csv.push(line);
                    });
                });
                csv = csv.join('\r\n');
                deferred.resolve(csv);
                Rally.getApp().setLoading(false);
            }
        });
        return deferred.promise;
    },

    getCSVFromRows: function(scope, grid, rows) {
        var me = this;
        var columns = grid.columns;
        var store = grid.getStore();

        console.log('getCSVFromRows');

        var model = grid.model;

        var csv = [];

        csv.push('"' + this._getHeadersFromGrid(grid).join('","') + '"');

        Ext.Array.each(rows,function(row){

            csv.push( me._getCSVFromRecord(Ext.create('recordHolder', { data:row}), grid, store) );
        });

        csv = csv.join('\r\n');
        return csv;
    },

    // custom grid assumes there store is fully loaded
    _getCSVFromCustomBackedGrid: function(grid, skip_headers) {
        var deferred = Ext.create('Deft.Deferred');
        var store = Ext.clone( grid.getStore() );
        var columns = grid.columns;
        Rally.getApp().setLoading("Generating CSV...");

        var record_count = store.getTotalCount(),
            page_size = store.pageSize,
            pages = Math.ceil(record_count/page_size),
            promises = [];

        for (var page = 1; page <= pages; page ++ ) {
            promises.push(this.loadStorePage(grid, store, columns, page, pages));
        }

        Deft.Promise.all(promises).then({
            scope: this,
            success: function(csvs){
                var csv = [];
                if ( !skip_headers ) {
                    csv.push('"' + this._getHeadersFromGrid(grid).join('","') + '"');
                }
                _.each(csvs, function(c){
                    _.each(c, function(line){
                        csv.push(line);
                    });
                });
                csv = csv.join('\r\n');
                deferred.resolve(csv);
                Rally.getApp().setLoading(false);
            }
        });
        return deferred.promise;
    },

    _getHeadersFromGrid: function(grid) {
        var headers = [];
        var columns = grid.columns;

        Ext.Array.each(columns,function(column){
            if ( column.hidden ) { return; }

            if ( column.dataIndex || column.renderer ) {
                if ( column.csvText ) {
                    headers.push(column.csvText.replace('&nbsp;',' '));
                } else if ( column.text )  {
                    headers.push(column.text.replace('&nbsp;',' '));
                }
            }
        });

        return headers;
    },

    _getColumnNamesFromGrid: function(grid) {
        var names = [];
        var columns = grid.columns;

        Ext.Array.each(columns,function(column){
            if ( column.dataIndex || column.renderer ) {
                names.push(column.dataIndex);
            }
        });

        return names;
    },
    /*
     * will render using your grid renderer.  If you want it to ignore the grid renderer,
     * have the column set _csvIgnoreRender: true
     */
    getCSVFromGrid:function(app, grid, skip_headers){
        this.logger.log("Exporting grid with store type:", Ext.getClassName(grid.getStore()));

        if ( Ext.getClassName(grid.getStore()) != "Rally.data.custom.Store" ) {
            return this._getCSVFromWsapiBackedGrid(grid,skip_headers);
        }

        return this._getCSVFromCustomBackedGrid(grid,skip_headers);
    },
    loadStorePage: function(grid, store, columns, page, total_pages){
        var deferred = Ext.create('Deft.Deferred');
        this.logger.log('loadStorePage',page, total_pages);

        store.loadPage(page, {
            callback: function (records) {
                var csv = [];
                Rally.getApp().setLoading(Ext.String.format('Page {0} of {1} loaded',page, total_pages));
                for (var i = 0; i < records.length; i++) {
                    var record = records[i];
                    csv.push( this._getCSVFromRecord(record, grid, store) );
                }
                deferred.resolve(csv);
            },
            scope: this
        });
        return deferred;
    },

    _getCSVFromRecord: function(record, grid, store) {
        //console.log('record:', record);

        var mock_meta_data = {
            align: "right",
            classes: [],
            cellIndex: 9,
            column: null,
            columnIndex: 9,
            innerCls: undefined,
            recordIndex: 5,
            rowIndex: 5,
            style: "",
            tdAttr: "",
            tdCls: "x-grid-cell x-grid-td x-grid-cell-headerId-gridcolumn-1029 x-grid-cell-last x-unselectable",
            unselectableAttr: "unselectable='on'"
        };

        var node_values = [];
        var columns = grid.columns;

        Ext.Array.each(columns, function (column) {
            if (column.xtype == 'rallyrowactioncolumn'  || column.xtype == 'tsrowactioncolumn') {
                return;
            }

            if ( column.hidden ) {
                return;
            }

            if (column.dataIndex) {
                var column_name = column.dataIndex;

                var display_value = record.get(column_name);

                if (!column._csvIgnoreRender && ( column.renderer || column.exportRenderer) ) {
                    if (column.exportRenderer) {
                        display_value = column.exportRenderer(display_value, mock_meta_data, record, 0, 0, store, grid.getView());
                    } else {
                        display_value = column.renderer(display_value, mock_meta_data, record, 0, 0, store, grid.getView());
                    }
                }
                node_values.push(display_value);
            } else {
                var display_value = null;
                if (!column._csvIgnoreRender && column.renderer) {
                    if (column.exportRenderer) {
                        display_value = column.exportRenderer(display_value, mock_meta_data, record, record, 0, 0, store, grid.getView());
                    } else {
                        display_value = column.renderer(display_value, mock_meta_data, record, record, 0, 0, store, grid.getView());
                    }
                    node_values.push(display_value);
                }
            }
        }, this);

        var csv_string = "";
        Ext.Array.each(node_values, function(node_value,idx){
            if ( idx > 0 ) {
                csv_string = csv_string + ",";
            }
            if (/^=/.test(node_value) ) {
                csv_string = csv_string + node_value;
            } else {
                csv_string = csv_string + '"' + node_value + '"';
            }

        });

        return csv_string;
    }

});
Ext.define('CA.techservices.validator.Validator',{
    alias: 'widget.tsvalidator',

    logger: new Rally.technicalservices.Logger(),
    /**
     *
     * [{rule}] An array of validation rules
     */
    rules: [],

    /**
     *
     */
    deliveryTeamProjects: [],       // listing of projects where a SCHEDULED feature might reside

    businessPlanningProjects: [],   // listing of programs where an UNSCHEDULED feature might reside

    recordsByModel: {},

    projectUtility: null, //This is the class passed in by initialize that holds the project hierarchy.  This is used for bucketing data
    currentProject: null, //Current project ObjectID so that we can determine which projects to display as "categories"

    categoryField: 'Project',

    // fields that all rules should fetch
    fetchFields: [],
    /**
     *
     * a hash containing events for a data point e.g.,
     *
     * points will include a field called _records holding the associated records
     * and each record will have a field called __ruleText holding a statement about
     * its violation
     *
     *     {
     *          click: function() {
     *          me.showDrillDown(this._records,this._name);
     *      }
     */
    pointEvents: null,
    /**
     *
     * a hash of filters by model type.  Filter will be ANDed to the filters we get from the validation rules
     * (which are themselves ORed together).
     */
    baseFilters: {},

    constructor: function(config) {
        Ext.apply(this,config);

        var rules = [];

        Ext.Array.each(this.rules, function(rule){

            var name = rule.xtype;
            if ( !Ext.isEmpty(name) ) {
                delete rule.xtype;
                rules.push(Ext.createByAlias('widget.' + name, rule));
            }
        });

        this.rules = rules;
    },

    getRuleDescriptions: function() {
        var text = "<ul>";

        Ext.Array.each(this.getRules(), function(rule){
            var rule_description = rule.getDescription() || "";
            if ( !Ext.isEmpty(rule_description) ) {
                text = text + "<li>" + rule_description + "</li>";
            }
        });
        text = text + "</ul>";
        return text;
    },

    getRules: function(){
        return this.rules;
    },

    getFiltersByModel: function() {
        var me = this,
            filters_by_model = {};

        Ext.Array.each(this.getRules(), function(rule){
            var model = rule.getModel();
            var filters = rule.getFilters();

            if ( !Ext.isEmpty(model) && !Ext.isEmpty(filters) ) {
                if ( Ext.isEmpty(filters_by_model[model]) ) {
                    filters_by_model[model] = [];
                }
                filters_by_model[model].push(filters);
            }
        });
        this.logger.log('filters_by_model', filters_by_model);

        Ext.Object.each(filters_by_model, function(model, filters){
            filters = Ext.Array.unique( Ext.Array.flatten(filters) );
            filters_by_model[model] = Rally.data.wsapi.Filter.or(filters);
            if ( me.baseFilters && !Ext.Object.isEmpty(me.baseFilters) && me.baseFilters[model] && me.baseFilters[model] != {} ) {
                filters_by_model[model] = filters_by_model[model].and(me.baseFilters[model]);
            }
        });
        return filters_by_model;
    },

    getFetchFieldsByModel: function() {
        var me = this,
            fields_by_model = {};

        Ext.Array.each(this.getRules(), function(rule){
            var model = rule.getModel();
            var fields = rule.getFetchFields();

            if ( !Ext.isEmpty(model) && !Ext.isEmpty(fields) && fields.length > 0 ) {
                if ( Ext.isEmpty(fields_by_model[model]) ) {

                    fields_by_model[model] = [me.categoryField,'Name'];
                }
                fields_by_model[model].push(fields);
            }
        });
        Ext.Object.each(fields_by_model, function(model, fields){
            fields = Ext.Array.flatten(fields);
            fields = Ext.Array.push(fields, me.fetchFields);

            fields_by_model[model] = Ext.Array.unique(fields);
        });

        return fields_by_model;
    },
    // returns a promise, promise fulfilled by hash of results by model type
    gatherData: function() {
        var deferred = Ext.create('Deft.Deferred'),
            me = this;


        var fetch_by_model = this.getFetchFieldsByModel();
        var filters_by_model = this.getFiltersByModel();


        var promises = [];
        Ext.Object.each(fetch_by_model, function(model, fetch){
            var config = {
                model: model,
                fetch: fetch,
                limit: Infinity,
                filters: filters_by_model[model]
            };

            var promise = function() {
                return this._loadWsapiRecords(config);
            };
            promises.push(promise);
        },this);

        console.log('promises', promises);

        Deft.Chain.sequence(promises,this).then({
            success: function(results) {
                me.recordsByModel = {};
                Ext.Array.each(results, function(result) {
                    me.recordsByModel = Ext.apply(me.recordsByModel, result);
                });
                deferred.resolve(results);
            },
            failure: function(msg) {
                deferred.reject(msg);
            }
        });
        return deferred.promise;
    },

    /**
     * getGridData
     *
     * @returns [{},{},...] (an array of data objects that can be used in a custom store
     *
     * the "category" field is the same as the category for the violation
     * each rule will be a column and the resulting grid will show a count
     *
     */
    getGridData: function(){
        if ( this.recordsByModel == {} ) {
            console.log('No search results');
            return [];
        }
        console.log('getGridData');
        var records = Ext.Array.flatten(Ext.Object.getValues(this.recordsByModel));

        var projectUtility = this.projectUtility,
            projectLevel = projectUtility.getProjectLevel(this.currentProject),
            hash = {};

        Ext.Array.each(records, function(r){
            var projectID = r.get('Project').ObjectID,
                bucket = projectUtility.getProjectAncestor(projectID, projectLevel+1),
                model = r.get('_type').toLowerCase();

            if (!hash[bucket]){
                hash[bucket] = {};
            }
            if (!hash[bucket][model]){
                hash[bucket][model] = [];
            }
            hash[bucket][model].push(r);
        }, this);


        var data = [],
            me = this;
        Ext.Object.each(hash, function(bucket, recordsByModel){
            var row = {
                bucket: this.projectUtility.getProjectName(bucket),
                bucketID: bucket
            };
            Ext.Array.each(this.getRules(), function(rule){
                var ruleId = rule.getUserFriendlyRuleLabel();
                var model = rule.getModel().toLowerCase();
                var records = recordsByModel[model] || [];

                var failed_records = me.getFailedRecordsForRule(records, rule);
                row[ruleId] = {
                    name: rule.getUserFriendlyRuleLabel(),
                    description: rule.getDescription(),
                    failedRecords: failed_records,
                    violations: failed_records.length
                };
            });
            data.push(row);
        }, this);
        return data;
    },
    //getChartData: function() {
    //    if ( this.recordsByModel == {} ) {
    //        console.log('No search results');
    //        return {};
    //    }
    //
    //    var categories = this.getCategories();
    //    var series = this.getSeries(categories);
    //
    //    return { series: series, categories: categories };
    //
    //},

    getBuckets: function() {
        var records = Ext.Array.flatten(Ext.Object.getValues(this.recordsByModel));

        var projects = Ext.Array.map(records, function(r){
            return r.get('Project').ObjectID;
        });
        projects = Ext.Array.unique(projects);

        var projectLevel = this.projectUtility.getProjectLevel(this.currentProject);

        var buckets = Ext.Array.map(projects, function(p) {
            return this.projectUtility.getProjectAncestor(p, projectLevel+1);
        }, this);

        return Ext.Array.unique(buckets);
    },

    getGridDataWithoutRecords: function(){
        var deferred = Ext.create('Deft.Deferred');
        var buckets = this.projectUtility.getProjectDirectChildren(this.currentProject),
            promises = [],
            me = this;
        Ext.Array.each(buckets, function(p){
            promises.push(me.fetchGridRow(p));
        });

        Deft.Promise.all(promises).then({
            success:function(rows){
                deferred.resolve(rows);
            },
            failure: function(msg){
                deferred.reject(msg);
            }
        });
        return deferred;
    },
    refreshRecord: function(record){
        var projectID = record.get('bucket');
        
        this.fetchGridRow(projectID).then({
            success: function(row){
                Ext.Object.each(row, function(field, value){
                    record.set(field, value);
                });
            }
        });
    },
    fetchGridRow: function(projectID){
        var deferred = Ext.create('Deft.Deferred'),
            me = this,
            promises = [],
            projectName = this.projectUtility.getProjectName(projectID),
            projectRef= '/project/' + projectID,
            rules = this.getRules();
        console.log('rules', rules);
        Ext.Array.each(rules, function(rule){
            var config = {
                model: rule.getModel(),
                fetch: rule.getFetchFields(),
                filters: rule.getFilters(),
                context: {project: projectRef, projectScopeDown: true}
            };
            console.log('fetchGridRow', config);
            console.log('fetchGridRow', config.filters.toString());
            promises.push(me._loadWsapiCount(config))
        });

        Deft.Promise.all(promises).then({
            success: function(results){
                var row = {
                    bucket: projectName,
                    bucketID: projectID,
                };
                for (var i=0; i < rules.length; i++){
                    var name = rules[i].getUserFriendlyRuleLabel();
                    row[name] = {id: rules[i].alias[0],
                                 value: results[i] || 0
                    };
                }
                deferred.resolve(row);
            },
            failure: function(msg){
                deferred.reject(msg);
            }
        });
        return deferred;
    },
    getFailedRecordsForRule: function(records, rule) {
        var failed_records = [];
        Ext.Array.each(records, function(record) {
            var failure = rule.applyRuleToRecord(record);
            if ( failure ) {
                var texts = record.get('__ruleText') || [];
                texts.push(failure);
                record.set('__ruleText', texts);
                failed_records.push(record);
            }
        });

        return failed_records;
    },

    _loadWsapiRecords: function(config) {
        var deferred = Ext.create('Deft.Deferred');

        Ext.create('Rally.data.wsapi.Store',config).load({
            callback: function(records, operation){
                if (operation.wasSuccessful()){
                    var result = {};
                    result[config.model] = records;
                    deferred.resolve(result);
                } else {
                    deferred.reject(operation.error.errors.join(','));
                }
            }
        });
        return deferred.promise;
    },
    _loadWsapiCount: function(config){
        var deferred = Ext.create('Deft.Deferred');

        config.pageSize = 1;
        config.limit = 1;

        Ext.create('Rally.data.wsapi.Store',config).load({
            callback: function(records, operation){
                if (operation.wasSuccessful()){
                    deferred.resolve(operation.resultSet.totalRecords);
                } else {
                    deferred.reject(operation.error.errors.join(','));
                }
            }
        });
        return deferred.promise;
    }
});
Ext.define('CA.technicalservices.DetailPanel', {
    extend: 'Ext.panel.Panel',
    alias: 'widget.detailpanel',

    cls: 'inline-filter-panel',
    flex: 1,
    header: false,
    minHeight: 300,
    padding: '8px 0 0 0',
    bodyPadding: '7px 5px 5px 5px',
    collapseDirection: 'top',
    collapsible: true,
    animCollapse: false,

    constructor: function(config) {
        this.mergeConfig(config);
        this.callParent([this.config]);
    },

    initComponent: function() {
        this.callParent(arguments);

        if (!this.stateful || (this.stateful && !this._hasState())) {
            this.applyState({});
        }

    },
    _hasState: function(){
        if (this.stateful && this.stateId) {
            return !!Ext.state.Manager.get(this.stateId);
        }
        return false;
    },
    _loadModels: function(state){
        if (this.models){
            this._addItems(state);
            return;
        }

        if (this.context && this.modelNames && this.modelNames.length > 0){
            Rally.data.ModelFactory.getModels({
                types: this.modelNames,
                context: this.context,
                success: function(models){
                    this.models = models;
                    this._addItems(state);
                },
                scope: this
            });
        }
    },
    _addItems: function(state){
        if (!state){
            state = {};
        }

        this.removeAll();

        this.add({
            xtype: 'rallybutton',
            cls: 'inline-filter-panel-close icon-cross',
            height: 18,
            userAction: 'Close (X) filter panel clicked',
            listeners: {
                click: function() {
                    this.collapse();
                },
                scope: this
            }
        });
        this.add({
            xtype: 'container',
            flex: 1,
            layout: 'hbox',
            items: [{
                xtype: 'rallyfieldcombobox',
                model: this.modelNames[0],
                itemId: 'cb-StateField',
                fieldLabel: "Cycle Time Field",
                labelAlign: 'right',
                labelWidth: 150,
                width: 300,
                context: this.context,
                value: state.cycleStateField,
                _isNotHidden: this._isCycleTimeField
            },{
                xtype: 'rallybutton',
                enableToggle: true,
                itemId: 'btBlocked',
                margin: '6 6 6 185',
                cls: state.showBlocked ? 'primary rly-small' : 'secondary rly-small',
                iconCls: 'icon-blocked',
                toolTipText: "Calculate time in Blocked state",
                pressed: state.showBlocked || false,
                listeners: {
                    toggle: this._toggleButton,
                    scope: this
                }
            }, {
                xtype: 'rallybutton',
                enableToggle: true,
                itemId: 'btReady',
                margin: 6,
                iconCls: 'icon-ok',
                cls: state.showReady ? 'primary rly-small' : 'secondary rly-small',
                pressed: state.showReady || false,
                toolTipText: "Calculate time in Ready state",
                listeners: {
                    toggle: this._toggleButton,
                    scope: this
                }
            }]
        });

        var fromStates = [],
            toStates = [];

        if (state.cycleStates && state.cycleStates.length > 0){
            Ext.Array.each(state.cycleStates, function(s){
                if (state.cycleStateField !== "ScheduleState"){
                    fromStates.push(CArABU.technicalservices.CycleTimeCalculator.creationDateText);
                }
                fromStates.push(s);
                if (!state.cycleEndState || (state.cycleEndState === s) || toStates.length > 0){
                    toStates.push(s);
                }
            });
            fromStates = _.map(state.cycleStates, function(s){ return {value: s}; });
            toStates = _.map(state.cycleStates, function(s){ return {value: s}; });
        }

        this.add({
            xtype: 'container',
            flex: 1,
            layout: 'hbox',
            items: [{
                xtype: 'rallycombobox',
                itemId: 'cb-fromState',
                allowBlank: true,
                allowNoEntry: true,
                noEntryText: '-- Creation --',
                noEntryValue: '-- Creation --',
                fieldLabel: 'Cycle Time State From',
                labelAlign: 'right',
                labelWidth: 150,
                width: 300,
                store: Ext.create('Rally.data.custom.Store', {data: fromStates}),
                value: state.cycleStartState || null,
                valueField: 'value',
                displayField: 'value'
            },{
                xtype: 'rallycombobox',
                itemId: 'cb-toState',
                fieldLabel: 'to',
                labelWidth: 15,
                labelAlign: 'right',
                width: 165,
                allowBlank: false,
                disabled: toStates.length === 0,
                store: Ext.create('Rally.data.custom.Store', {data:toStates}),
                value: state.cycleEndState || null,
                valueField: 'value',
                displayField: 'value',
                listeners: {
                    scope: this,
                    select: this.updateCycleTimeParameters
                }
            }]

        },{
            xtype: 'container',
            flex: 1,
            layout: 'hbox',
            items: [{
                xtype: 'rallydatefield',
                fieldLabel: 'Cycle End Date From',
                labelSeparator: "",
                itemId: 'dtFrom',
                labelAlign: 'right',
                labelWidth: 150,
                width: 300,
                value: state.startDate || null,
                toolTipText: "If this is populated, cycle time will only be shown for artifacts that transitioned into the selected Cycle End State AFTER this date.",

                listeners: {
                    scope: this,
                    select: this.updateCycleTimeParameters
                }
            },{
                xtype: 'rallydatefield',
                fieldLabel: 'to',
                itemId: 'dtTo',
                labelAlign: 'right',
                labelSeparator: "",
                labelWidth: 15,
                width: 165,
                value: state.endDate || null,
                toolTipText: "If this is populated, cycle time will only be shown for artifacts that transitioned into the selected Cycle End State BEFORE this date.",
                listeners: {
                    scope: this,
                    select: this.updateCycleTimeParameters
                }
            }]
        });

        this.down('#cb-fromState').on('select', this._updateToState, this);

        var stateFieldCb = this.down('#cb-StateField');
        stateFieldCb.on('ready', this._updateStateDropdowns, this);
        stateFieldCb.on('select', this._updateStateDropdowns, this);

        this._updateStateDropdowns(stateFieldCb);
        this.updateCycleTimeParameters();
    },
    clear: function(){
        this._getFromStateCombo().setValue(null);
    },
    getState: function(){
        var currentState = this.getCycleTimeParameters();
        if (currentState.cycleStates && Ext.isArray(currentState.cycleStates)){
            currentState.cycleStates = currentState.cycleStates.join(',');
        }
        return currentState;
    },
    _getStateFieldCombo: function(){
        return this.down('#cb-StateField') || null;
    },
    _getFromStateCombo: function(){
        return this.down('#cb-fromState') || null;
    },
    _getToStateCombo: function(){
        return this.down('#cb-toState') || null;
    },

    applyState: function(state){
        if (state && state.cycleStates && !Ext.isArray(state.cycleStates)){
            state.cycleStates = state.cycleStates.split(',');
        }
        this._loadModels(state);
    },
    _updateToState: function(cbFrom){

        var toStateCombo = this.down('#cb-toState');

        toStateCombo && toStateCombo.setDisabled(true);

        if (!cbFrom || !cbFrom.getValue() || !cbFrom.getRecord() || !toStateCombo){
            return;
        }

        var data = [],
            fromValue = cbFrom.getValue();
        Ext.Array.each(cbFrom.getStore().getRange(), function(d){
            if (fromValue === d.get('value') || data.length > 0){
                data.push(d.getData());
            }
        });
        toStateCombo.setDisabled(false);
        toStateCombo.bindStore(Ext.create('Rally.data.custom.Store',{ data: data}));
        //if (this.state && this.state.cycleEndState && toStateCombo.getValue() !== this.state.cycleEndState){
        //    toStateCombo.setValue(this.state.cycleEndState);
        //}
        this.updateCycleTimeParameters();
    },
    hasValidCycleTimeParameters: function(){

        var fromState = this.down('#cb-fromState') && this.down('#cb-fromState').getValue(),
            toState = this.down('#cb-toState') && this.down('#cb-toState').getValue();

        if(!fromState || !toState){
            return false;
        }
        return true;
    },
    getCycleTimeParameters: function(){
        var cycleTimeField = this._getStateFieldCombo() && this._getStateFieldCombo().getValue() || null,
            cycleStartState = this._getFromStateCombo() && this._getFromStateCombo().getValue() || null,
            cycleEndState = this._getToStateCombo() && this._getToStateCombo().getValue() || null,
            showReady = this.down('#btReady') && this.down('#btReady').pressed || false,
            showBlocked = this.down('#btBlocked') && this.down('#btBlocked').pressed || false,
            cycleEndRangeStart = this.down('#dtFrom') && this.down('#dtFrom').getValue() || null,
            cycleEndRangeTo = this.down('#dtTo') && this.down('#dtTo').getValue() || null,
            states = this.down('#cb-fromState') && this.down('#cb-fromState').getStore().getRange() || [];

        states = Ext.Array.map(states, function(r) {
            //if (r.get('value') !== CArABU.technicalservices.CycleTimeCalculator.creationDateText) {
            return r.get('value');
        });
        states = _.uniq(states);
        return {
            cycleStateField: cycleTimeField,
            cycleStartState: cycleStartState,
            cycleEndState: cycleEndState,
            showReady: showReady,
            showBlocked: showBlocked,
            startDate: cycleEndRangeStart,
            endDate: cycleEndRangeTo,
            cycleStates: states
        };
    },
    updateCycleTimeParameters: function(){
        this.saveState();
        if (this.hasValidCycleTimeParameters()){
            this.fireEvent('parametersupdated', this.getCycleTimeParameters());
        } else {
            this.fireEvent('parametersupdated', {});
        }
    },
    _isCycleTimeField: function(field){
        var whitelistFields = ['State','ScheduleState'];

        if (field.hidden){
            return false;
        }

        if (Ext.Array.contains(whitelistFields, field.name)){
            return true;
        }

        if (field.readOnly){
            return false;
        }

        var allowed_attribute_types = ['STATE','STRING'],
            attributeDef = field && field.attributeDefinition;
        if (attributeDef){
            if ( attributeDef.Constrained && Ext.Array.contains(allowed_attribute_types, attributeDef.AttributeType)) {
                return true;
            }
        }
        return false;
    },
    _toggleButton:  function(btn, state){

        if (state){
            btn.removeCls('secondary');
            btn.addCls('primary');
        } else {
            btn.removeCls('primary');
            btn.addCls('secondary');
        }
        this.updateCycleTimeParameters();
    },
    _updateStateDropdowns: function(cb){

        var fromStateCombo = this.down('#cb-fromState'),
            toStateCombo = this.down('#cb-toState');

        var toStatePreviousValue = toStateCombo && toStateCombo.getValue(),
            fromStatePreviousValue = fromStateCombo && fromStateCombo.getValue();

        fromStateCombo && fromStateCombo.setDisabled(true);
        toStateCombo &&  toStateCombo.setDisabled(true);
        var store = Ext.create('Rally.data.custom.Store',{
            data: []
        });
        toStateCombo.bindStore(store);

        if (!cb || !cb.getValue() || !cb.getRecord()){
            return;
        }

        var model = cb.model;

        var data = [];
        if (cb.getValue() !== "ScheduleState"){
            data.push({value: CArABU.technicalservices.CycleTimeCalculator.creationDateText });
        }
        model.getField(cb.getValue()).getAllowedValueStore().load({
            callback: function(records, operation){
                Ext.Array.each(records,function(r){
                    data.push({value: r.get('StringValue') });
                });
                var store = Ext.create('Rally.data.custom.Store',{
                    data: data
                });
                fromStateCombo.bindStore(store);
                fromStateCombo.setDisabled(false);
                if (fromStatePreviousValue){
                    fromStateCombo.setValue(fromStatePreviousValue);
                }

                toStateCombo.bindStore(store);
                toStateCombo.setDisabled(false);
                if (toStatePreviousValue){
                    toStateCombo.setValue(toStatePreviousValue);
                }

                this.updateCycleTimeParameters();
            },
            scope: this
        });

    }
});
Ext.define('CA.technicalservices.utils.ProjectUtilities',{

    fetch: ['ObjectID','Name','Parent'],
    mixins: {
        observable: 'Ext.util.Observable'
    },
    constructor: function(config){
        this.mixins.observable.constructor.call(this, config);

        var fetch = Ext.Array.merge(this.fetch, config && config.fetch || []);

        Ext.create('Rally.data.wsapi.Store',{
            model: 'Project',
            fetch: ['ObjectID','Name','Parent'],
            limit: Infinity,
            context: {project: null},
            pageSize: 2000,
            compact: false
        }).load({
            callback: function(records, operation){
                if (operation.wasSuccessful()){
                    this._buildProjectParentHash(records);
                } else {
                    this.fireEvent('onerror', "Error fetching projects: " + operation.error && operation.error.errors.join(','));
                }
            },
            scope: this
        });
    },
    _buildProjectParentHash: function(records){

        var projectHash = {};
        Ext.Array.each(records, function(r){
            projectHash[r.get('ObjectID')] = r.getData();
        });
        this.projectHash= projectHash;
        this.fireEvent('ready');
    },
    getAncestry: function(projectID){
        var parent = this.projectHash[projectID].Parent && this.projectHash[projectID].Parent.ObjectID || null,
            ancestry = this.projectHash[projectID] && this.projectHash[projectID].ancestors;

        if (!ancestry){
            ancestry = [projectID];
            if (parent){
                do {
                    ancestry.unshift(parent);
                    parent = this.projectHash[parent] &&
                        this.projectHash[parent].Parent &&
                        this.projectHash[parent].Parent.ObjectID || null;

                } while (parent);
            }
            this.projectHash[projectID].ancestors = ancestry;
        }
        return ancestry;
    },
    getProjectAncestor: function(projectID, projectLevel){
        var ancestry = this.getAncestry(projectID);

        if (ancestry.length >= projectLevel){
            return ancestry[projectLevel - 1];
        }
        return null;
    },
    getProjectName: function(projectID){
        return this.projectHash[projectID] &&  this.projectHash[projectID].Name || "Unknown";
    },
    getProjectLevel: function(projectID){
        var ancestory = this.getAncestry(projectID);
        return ancestory.length;
    },
    isProjectLeafNode: function(projectID){
        var isLeafNode = true;
        var ms = Date.now();
        Ext.Object.each(this.projectHash, function(key, data){
            if (data.Parent && data.Parent.ObjectID === projectID){
                isLeafNode = false;
                return false;
            }
        });
        console.log('isProjectLeafNode',(Date.now() - ms)/1000);

        return isLeafNode;
    },
    getProjectDirectChildren: function(projectID){
        var children = [];
        Ext.Object.each(this.projectHash, function(key, data){
            if (data.Parent && data.Parent.ObjectID === projectID){
                children.push(key);
            }
        });
        return children;
    }
});
Ext.define("data-exception-summary", {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    defaults: { margin: 10 },

    integrationHeaders : {
        name : "data-exception-summary"
    },
    layout: 'hbox',

    items: [
        {xtype:'container', itemId:'grid_box', flex: 1},
        {xtype:'container', itemId:'detail_box'}
    ],

    showDetails: function(view, cell, cellIndex, record) {
        this.logger.log('showDetails', view, record);

        var clickedDataIndex = view.panel.headerCt.getHeaderAtIndex(cellIndex).dataIndex;
        var ruleValue = record.get(clickedDataIndex);

        if (!Ext.isObject(ruleValue)){
            return;
        }

        var projectRef = '/project/' + record.get('bucketID'),
            projectName = record.get('bucket'),
            context = this.getContext(),
            rule = Ext.createByAlias(ruleValue.id, {
                portfolioItemTypes: this.portfolioItemTypes
            }),
            modelNames = [rule.getModel()];


        var box = this.getDetailBox();
        box.removeAll();

        Ext.create('Rally.data.wsapi.TreeStoreBuilder').build({
            models: modelNames,
            enableHierarchy: true,
            fetch: rule.getDetailFetchFields(),
            filters: rule.getFilters(),
            context: {
                project: projectRef,
                projectScopeDown: true
            }
        }).then({
            success: function(store) {
                store.on('update', function(){
                    this.validator.refreshRecord(record);
                }, this);

        box.add({
            xtype:'panel',
            ui: 'info-box',
            hideCollapseTool: true,
            collapsible: true,
            collapsed: false,
            collapseDirection: 'right',
            headerPosition: 'left',
            header: true,
            cls: 'detail-panel',
            width: this.getWidth() *.90,
            height: this.getHeight(),
            padding: 10,
            overflowY: 'auto',
            items: [{
                xtype: 'container',
                flex: 1,
                layout: 'hbox',
                items: [{
                    xtype: 'rallybutton',
                    cls: 'detail-collapse-button icon-leave',
                    width: 18,
                    margin: '0 10 0 25',
                    userAction: 'Close (X) filter panel clicked',
                    listeners: {
                        click: function() {
                            //this.up('panel').collapse();
                            this.up('panel').destroy();
                        }
                    }
                },{
                    xtype: 'container',
                    flex: 1,
                    html: Ext.String.format('<div class="rule-title">{1} ({0})</div><div class="rule-description">{2}</div>',projectName, rule.getUserFriendlyRuleLabel(),rule.getDescription())
                }]
            },{
                xtype: 'rallygridboard',
                context: context,
                modelNames: modelNames,
                toggleState: 'grid',
                plugins: [{
                    ptype: 'rallygridboardinlinefiltercontrol',
                    inlineFilterButtonConfig: {
                    stateful: true,
                        stateId: context.getScopedStateId('filters'),
                        modelNames: modelNames,
                        inlineFilterPanelConfig: {
                        quickFilterPanelConfig: {
                            defaultFields: [
                                'ArtifactSearch',
                                'Owner',
                                'Project'
                            ]
                        }
                    }
                }
                },{
                    ptype: 'rallygridboardfieldpicker',
                    headerPosition: 'left',
                    modelNames: modelNames,
                    stateful: true,
                    stateId: context.getScopedStateId('columns-example')
                },{
                    ptype: 'rallygridboardactionsmenu',
                    menuItems: [
                        {
                            text: 'Export...',
                            handler: function() {
                                window.location = Rally.ui.gridboard.Export.buildCsvExportUrl(
                                    this.down('rallygridboard').getGridOrBoard());
                            },
                            scope: this
                        }
                    ],
                    buttonConfig: {
                        iconCls: 'icon-export'
                    }
                }],
                gridConfig: {
                    store: store,
                    storeConfig: {
                        filters: rule.getFilters(),
                        pageSize: 10,
                        context: {
                            project: projectRef,
                            projectScopeDown: true
                        }
                    },
                    columnCfgs: rule.getDetailFetchFields()

                },
                height: this.getHeight()

                //xtype: 'rallygrid',
                //storeConfig: {
                //    model: rule.getModel(),
                //    fetch: rule.getDetailFetchFields(),
                //    filters: rule.getFilters(),
                //    context: {
                //        project: projectRef,
                //        projectScopeDown: true
                //    },
                //    pageSize: 10
                //},
                //margin: 15,
                //columnCfgs: rule.getFetchFields()
            }]
        });
            },
            scope: this
        });
    },

    config: {
        defaultSettings: {
            projectBuildPercentField: 'c_BuildPercent'
        }
    },

    scheduleStates: ['Defined','In-Progress','Completed','Accepted'],

    launch: function() {
        // get any data model customizations ... then get the data and render the chart
        this._fetchPortfolioItemTypes().then({
            success: this._initializeApp,
            failure: this.showErrorNotification,
            scope: this
        });
    },
    updateRecord: function(record, field, rule){
        var projectID = record.get('bucket'),
            newVal = rule.fetchUpdate(projectID).then({

            success: function(newVal){
                var ruleVal = record.get(field);
                if (ruleVal && ruleVal.value !== newVal){
                    ruleVal.value = newValue;
                    record.update(field, ruleVal);
                }
            }
        });

    },
    _initializeApp: function(portfolioItemTypes){
        this.logger.log('InitializeApp',portfolioItemTypes);

        this.portfolioItemTypes = portfolioItemTypes;
        this.projectUtility = Ext.create('CA.technicalservices.utils.ProjectUtilities',{
            fetch: [this.getSetting('projectBuildPercentField')],
            listeners: {
                onerror: this.showErrorNotification,
                ready: this.initializeValidator,
                scope: this
            }
        });
    },
    showErrorNotification: function(msg){
        Rally.ui.notify.Notifier.showError({message:msg});
    },
    _fetchPortfolioItemTypes: function(){
        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.wsapi.Store',{
            model: 'typedefinition',
            fetch:['TypePath','Ordinal','Name'],
            filters: [{property:'TypePath',operator:'contains',value:'PortfolioItem/'}],
            sorters: [{property:'Ordinal',direction:'ASC'}]
        }).load({
            callback: function(records,operation){
                if (operation.wasSuccessful()){
                    var portfolioItemArray = [];
                    Ext.Array.each(records,function(rec){
                        portfolioItemArray.push(rec.getData());
                    });
                    deferred.resolve(portfolioItemArray);
                } else {
                    var message = 'failed to load Portfolio Item Types ' + (operation.error && operation.error.errors.join(','));
                    deferred.reject(message);
                }
            }
        });
        return deferred;
    },
    initializeValidator: function(){
        var me = this;

        this.validator = this._createValidator();

        Deft.Chain.pipeline([
            function() {
                me.setLoading("Counting data...");
                return me.validator.getGridDataWithoutRecords();
            //},
            //function() {
            //    me.setLoading("Gathering data...");
            //    return me.validator.gatherData();
            //},
            //function() {
            //    me.setLoading("Analyzing data...");
            //    return me.validator.getGridData();
            }
        ]).then({
            scope: this,
            success: function(results) {
                this.logger.log('_loadData results', results);
                this._buildGrid(results);
            },
            failure: function(msg) {
                Ext.Msg.alert('Problem loading data', msg);
            }
        }).always(function() { me.setLoading(false); });
    },

    _buildGrid: function(data){

        if (!data || data.length === 0){
            return;
        }

        var fields = Ext.Object.getKeys(data[0]);

        var store = Ext.create('Rally.data.custom.Store',{
            data: data,
            fields: fields
        });

        var columnCfgs = [{
            dataIndex: 'bucket',
            text: 'Team',
            flex: 1
        }];

        Ext.Array.each(fields, function(f){
            if (f !== 'bucket' && f !== 'bucketID') {
                columnCfgs.push({
                    dataIndex: f,
                    text: f,
                    renderer: function(v,m){
                        m.tdCls = 'drilldown';
                        return v.value;
                    },
                    cls: 'drilldown',
                    doSort: function(direction){
                        var ds = this.up('rallygrid').getStore();
                        ds.sort({
                            property: f,
                            direction: direction,
                            sorterFn: function(v1, v2){
                                //var a = v1.get(f) && v1.get(f).violations || 0,
                                //    b = v2.get(f) && v2.get(f).violations || 0;
                                var a = v1.get(f) && v1.get(f).value || 0,
                                    b = v2.get(f) && v2.get(f).value || 0;
                                return a > b ? 1 : (a < b ? -1 : 0);
                            }
                        });
                    }
                });
            }
        });
        this.getGridBox().removeAll();
        this.getGridBox().add({
            xtype: 'rallygrid',
            store: store,
            margin: 20,
            columnCfgs: columnCfgs,
            showPagingToolbar: false,
            showRowActionsColumn: false,
            viewConfig: {
                listeners: {
                    cellclick: this.showDetails,
                    scope: this
                }
            },
            selModel: Ext.create("Ext.selection.CellModel",{
                //listeners: {
                //    select: this.showDetails,
                //    scope: this
                //}
            })
        });

    },
    mouseover: function(view, record, item, index, e, eOpts ){
        this.logger.log('mouseover', view, record, item, index, e);
    },
    getDetailBox: function(){
        return this.down('#detail_box');
    },
    getGridBox: function(){
        return this.down('#grid_box');
    },
    getUserFriendlyName: function(type){
        var name = '';
        if (/PortfolioItem/.test(type)){
            Ext.Array.each(this.portfolioItemTypes, function(p){
                if (p.TypePath === type){
                    name = p.Name;
                    return false;
                }
            });
        }
        if (type === 'HierarchicalRequirement'){
            name = 'User Story';
        }

        return name;
    },
    _createValidator: function() {
        var rules = [{
            xtype:'tsrule_portfolioorphan',
            targetPortfolioLevel: 0,
            portfolioItemTypes: this.portfolioItemTypes
        },{
            xtype: 'tsrule_userstoryorphan',
            portfolioItemTypes: this.portfolioItemTypes
        },{
            xtype: 'tsrule_unsizedstories',
            portfolioItemTypes: this.portfolioItemTypes
        },{
            xtype: 'tsrule_leafnodestories',
            portfolioItemTypes: this.portfolioItemTypes
        },{
            xtype: 'tsrule_activestoriesinactiveinitiative',
            portfolioItemTypes: this.portfolioItemTypes
        },{
            xtype: 'tsrule_portfolionotsized',
            portfolioItemTypes: this.portfolioItemTypes
        },{
            xtype: 'tsrule_investmentcategorymisaligned',
            portfolioItemTypes: this.portfolioItemTypes
        },{
            xtype: 'tsrule_activestoryemptyteam',
            portfolioItemTypes: this.portfolioItemTypes
        }];

        var validator = Ext.create('CA.techservices.validator.Validator',{
            rules: rules,
            projectUtility: this.projectUtility,
            currentProject: this.getContext().getProject().ObjectID,
            fetchFields: ['FormattedID','ObjectID','Project']
        });
        return validator;
    },
    getSettingsFields: function(){
        var labelWidth = 150;

        return [];
    },
    getOptions: function() {
        return [
            {
                text: 'About...',
                handler: this._launchInfo,
                scope: this
            }
        ];
    },
    _launchInfo: function() {
        if ( this.about_dialog ) { this.about_dialog.destroy(); }
        this.about_dialog = Ext.create('Rally.technicalservices.InfoLink',{});
    },
    isExternal: function(){
        return typeof(this.getAppId()) == 'undefined';
    },
    //onSettingsUpdate:  Override
    onSettingsUpdate: function (settings){
        this.logger.log('onSettingsUpdate',settings);
        // Ext.apply(this, settings);
        this.launch();
    }
});

            
               Rally.launchApp('data-exception-summary', {
                   name: 'Data Exception Summary'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}

.rule-title {
    color: #222222;
    font-family: ProximaNovaSemiBold, Helvetica, Arial;
    font-size: 14px;
    padding-top: 5px;
}

.rule-description {
    bottom: 7px;
    color: #888888;
    font-family: ProximaNova, Helvetica, Arial;
    font-size: 11px;
    width: 100%;
}

.detail-panel {
    border-left-style: solid;
    border-left-width: 5px;
    border-left-color: #d6d6d6;
}

.detail-collapse-button {
    background-color: transparent;
    color: #a9a9a9;
    font-size: 16px;
    line-height: 12px;
    vertical-align: middle;
    margin: 10px 0 0 0;
    padding: 10px 0 0 0;
    right: 8px;
    top: 16px;
    z-index: 2;
}

.rally-grid .drilldown .x-grid-cell-inner:hover {
    color:#00a9e0!important;
    cursor: pointer!important;
    font-family: ProximaNovaBold, Helvetica, Arial;
    font-size: 12px;
}

    </style>

</head>
<body></body>
</html>